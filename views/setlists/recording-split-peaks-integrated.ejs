<div class="container mt-4" data-total-songs="<%= totalSongs %>">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
          <h1>
            Split Recording <%- typeof useWebAudio !== 'undefined' &&
            useWebAudio ? '(Web Audio)' : '(Peaks.js)' %>
          </h1>
          <h2 class="h5 text-muted"><%= setlist.title %></h2>
        </div>
        <div class="d-flex gap-2">
        <a
          href="/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>"
          class="btn btn-outline-secondary"
        >
          <i class="bi bi-arrow-left"></i> Back to Setlist
        </a>
          <a
            href="/bands/<%= setlist.band.id %>"
            class="btn btn-outline-primary"
          >
            <i class="bi bi-house"></i> Back to Band
          </a>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- Main Waveform Editor -->
    <div class="col-lg-9">
      <div class="card">
        <div
          class="card-header d-flex justify-content-between align-items-center"
        >
          <h5 class="mb-0">
            <i class="bi bi-scissors"></i> Mark Song Boundaries
          </h5>
          <div class="d-flex gap-2">
            <a
              href="/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>/recordings"
              class="btn btn-sm btn-outline-secondary"
            >
              <i class="bi bi-arrow-left"></i> Back to Recordings
            </a>
          </div>
        </div>
        <div class="card-body">
          <!-- Add custom styles for segment labels -->
          <style>
            .peaks-segment-label {
              position: absolute;
              top: 5px;
              left: 5px;
              color: white;
              background-color: rgba(
                0,
                0,
                0,
                0.6
              ); /* Slightly darker for better contrast */
              padding: 3px 6px;
              border-radius: 3px;
              font-size: 12px;
              font-weight: 600; /* Bolder text */
              pointer-events: none; /* Allows clicks to pass through to the segment */
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              max-width: calc(
                100% - 10px
              ); /* Prevent label from overflowing the segment */
              opacity: 1 !important; /* Force the label to be visible */
              transition: none !important; /* Disable any fade transitions */
            }
          </style>

          <!-- Loading Progress -->
          <div id="loadingProgress" class="text-center mb-3">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">
              <small class="text-muted">Loading audio file...</small>
            </div>
            <div class="progress mt-2" style="height: 6px">
              <div
                id="loadingBar"
                class="progress-bar progress-bar-striped progress-bar-animated"
                role="progressbar"
                style="width: 0%"
              ></div>
            </div>
            <div id="loadingStatus" class="mt-1">
            <small class="text-muted">Preparing waveform (a 500&nbsp;MB file may take about a minute to load the waveform)...</small>
          </div>
          <!-- Unlock button (shown for all as a fallback) -->
          <div class="mt-2" id="safariUnlockContainer" style="display: none;">
            <button id="safariLoadBtn" class="btn btn-sm btn-outline-primary">
              <i class="bi bi-lightning"></i> Click to load waveform
            </button>
            </div>
            <div id="loadingNote" class="mt-2" style="display: none">
              <small class="text-info">
                <i class="bi bi-info-circle"></i>
                Large files may take 30+ seconds to process. Please be patient.
              </small>
            </div>
          </div>

          <!-- MP3 Warning -->
          <% if (typeof recording !== 'undefined' && recording.filePath && recording.filePath.includes('.mp3')) { %>
          <div class="alert alert-warning alert-dismissible fade show" role="alert">
            <h6 class="alert-heading">
              <i class="bi bi-exclamation-triangle-fill"></i> MP3 Timing Notice
            </h6>
            <p class="mb-0">
              <strong>Important:</strong> For MP3 files, the waveform may appear drastically offset from the audio playback.
            </p>
            <hr>
            <p class="mb-2">
              <strong>Trust the waveform</strong> for marking song boundaries, not the audio playback timing.
            </p>
            <p class="mb-2">
              <strong>Tip:</strong> Use the <i class="bi bi-magic"></i> <strong>Auto-Detect Silence</strong> button below to automatically find song breaks.
            </p>
            <p class="mb-0">
              <strong>For best results:</strong> Upload <strong>.ogg</strong> or <strong>.webm</strong> files - they're still high quality but use 75% less space than .wav files.
            </p>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
          </div>
          <% } %>

          <!-- Peaks.js Waveform Containers -->
          <div
            id="overview-container"
            style="
              height: 100px;
              border: 1px solid #dee2e6;
              border-radius: 4px;
              background: #f8f9fa;
              display: none;
            "
          ></div>
          <div
            id="zoomview-container"
            style="
              height: 200px;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              background: #f8f9fa;
              display: none;
              overflow-y: hidden;
            "
          ></div>

          <!-- Playback Controls -->
          <div
            class="mt-3 d-flex justify-content-center gap-2 align-items-center"
          >
            <button
              id="playPauseBtn"
              class="btn btn-primary"
              style="width: 100px"
            >
              <i class="bi bi-play-fill"></i> Play
            </button>
            <button id="stopBtn" class="btn btn-secondary">
              <i class="bi bi-stop-fill"></i> Restart
            </button>
            <div class="mx-3" style="width: 180px; text-align: center">
              <span id="currentTime">0:00</span> /
              <span id="totalTime">0:00</span>
            </div>
            <div class="d-flex align-items-center gap-2">
              <label for="zoom" class="mb-0">Zoom:</label>
              <input
                type="range"
                id="zoom"
                min="0"
                max="100"
                value="0"
                step="1"
                class="form-range"
                style="width: 150px"
              />
              <button
                id="resetZoomBtn"
                class="btn btn-sm btn-outline-secondary"
              >
                <i class="bi bi-arrow-clockwise"></i> Reset
              </button>
            </div>
          </div>

          <hr />

          <!-- Utility Buttons -->
          <div class="mt-3 d-flex gap-2 justify-content-center flex-wrap">
            <button
              id="undoBtn"
              onclick="undoLastRegion()"
              class="btn btn-outline-warning"
              disabled
            >
              <i class="bi bi-arrow-counterclockwise"></i> Undo Last Segment
              <kbd>ESC</kbd>
            </button>
            <button
              id="autoDetectBtn"
              class="btn btn-outline-info"
              disabled
              onclick="autoDetectSilence()"
            >
              <span
                id="autoDetectSpinner"
                style="display: none; margin-right: 5px"
              >
                <span
                  class="spinner-border spinner-border-sm"
                  role="status"
                  aria-hidden="true"
                ></span>
              </span>
              <i class="bi bi-magic"></i> Auto-Detect Songs
            </button>
            <% if (typeof canSplit !== 'undefined' && !canSplit) { %>
              <button id="processSplitsBtn" class="btn btn-success" disabled 
                      style="opacity: 0.65; cursor: not-allowed;"
                      title="<%= typeof splitCheckMessage !== 'undefined' ? splitCheckMessage : 'Cannot split recording: insufficient storage space' %>">
                <i class="bi bi-scissors"></i> Process Splits
              </button>
            <% } else { %>
              <button id="processSplitsBtn" class="btn btn-success" disabled>
                <i class="bi bi-scissors"></i> Process Splits
              </button>
            <% } %>
          </div>

          <% if (typeof canSplit !== 'undefined' && !canSplit) { %>
          <div class="alert alert-warning mt-3 mb-0">
            <i class="bi bi-exclamation-triangle"></i> 
            <strong>Cannot Split Recording:</strong> 
            <%= typeof splitCheckMessage !== 'undefined' ? splitCheckMessage : 'Insufficient storage space available. The band\'s free pool is full and the recording creator has no remaining quota space.' %>
          </div>
          <% } %>

          <hr />

          <!-- Instructions -->
          <style>
            kbd {
              background-color: #0d6efd;
              color: white;
              padding: 2px 6px;
              border-radius: 4px;
              border: 1px solid #0a58ca;
            }
          </style>
          <div class="mt-3 alert alert-info">
            <strong
              ><i class="bi bi-info-circle"></i> Key Commands &
              Workflow:</strong
            >
            <ul class="mb-0 mt-2">
              <li>
                <strong>Create Segment:</strong> Click and drag on the main
                waveform. The new segment will be highlighted yellow, making it
                the active selection.
              </li>
              <li>
                <strong>Resize Segment:</strong> You can resize segments by dragging their edges.
              </li>
              <li>
                <strong>Auto-Detect:</strong> Use the Auto Detect Silence button to automatically select segments for songs.
              </li>
              <li>
                <strong>Assign Song:</strong> With a segment selected (yellow),
                click a song from the "Available Songs" list on the right.
              </li>
              <li>
                <strong>To Zoom:</strong> Use the zoom slider to get a more
                detailed view.
              </li>
              <li>
                <strong>To Pan/Scroll View:</strong> Hold <kbd>Option</kbd> (or
                <kbd>Alt</kbd>) while clicking and dragging the main waveform to
                move it left and right.
              </li>
              <li>
                <strong>Seek Playhead:</strong> Click anywhere on the waveform
                to move the playhead to that spot.
              </li>
              <li>
                <strong>Delete Segment:</strong> Press <kbd>Delete</kbd> or <kbd>Backspace</kbd> with a segment selected to delete it, or use the list below to manually delete them.
              </li>
              <li>
                <strong>Undo:</strong> Press <kbd>ESC</kbd> or click the "Undo"
                button to remove the last created segment.
              </li>
              <li>
                <strong>Process:</strong> When all songs are assigned, click
                "Process Splits".
              </li>
            </ul>
          </div>
          <div id="processSplitsStatus" class="text-center mt-2">
            <small class="text-muted"
              >Assign songs to segments to enable processing</small
            >
          </div>
        </div>
      </div>
    </div>

    <!-- Song Assignment Panel -->
    <div class="col-lg-3">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0"><i class="bi bi-list-music"></i> Song Assignment</h5>
        </div>
        <div class="card-body">
          <!-- Selected Segment - Moved to top -->
          <div class="mb-3">
            <h6>Selected Segment:</h6>
            <div
              id="selectedSegmentInfo"
              class="p-2 border rounded bg-dark text-light"
            >
              <p class="mb-0">No segment selected</p>
            </div>
          </div>

          <!-- Available Songs -->
          <div class="mb-3">
            <h6>Available Songs:</h6>
            <div id="songsList" class="list-group">
              <!-- Songs will be populated here -->
            </div>
          </div>

          <!-- Add New Song -->
          <div class="mb-3">
            <h6>Add New Song:</h6>
            <div class="p-2 border rounded bg-dark text-light">
              <p class="small mb-2">
                If you played a song that wasn't in the setlist or repeated a song, add it here:
              </p>
              <div class="input-group input-group-sm">
                <input
                  type="text"
                  id="unlistedSongTitle"
                  class="form-control"
                  placeholder="Enter song title..."
                />
            <button
                  id="addSongBtn"
                  class="btn btn-outline-light"
            >
                  <i class="bi bi-plus"></i> Add
            </button>
          </div>
        </div>
          </div>

      </div>
    </div>
  </div>
</div>

  <!-- Segments Assigned Panel - Below Waveform -->
  <div class="row">
    <div class="col-lg-9">
      <div class="card mt-3">
        <div class="card-header">
          <h6 class="mb-0">Segments Assigned:</h6>
        </div>
        <div class="card-body">
          <div id="segmentsList">
            <p class="text-muted small mb-0">
              No segments created yet. Drag on the waveform to create segments.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Add Song Modal -->
<div class="modal fade" id="addSongModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add New Song</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="songMatchResults">
          <!-- Loading state -->
          <div id="songMatchLoading" class="text-center py-4">
            <div class="spinner-border" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Searching for similar songs...</p>
          </div>
          
          <!-- Results will be populated here -->
          <div id="songMatchContent" style="display: none;">
            <!-- Option 1: Create New -->
            <div class="mb-4">
              <h6><strong>Create New Song</strong></h6>
              <div class="card new-song-card" style="cursor: pointer;">
                <div class="card-body">
                  <div class="mb-3">
                    <label class="form-label">Song Title</label>
                    <input type="text" id="newSongTitle" class="form-control" placeholder="Enter song title">
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Artist</label>
                    <input type="text" id="newSongArtist" class="form-control" placeholder="Enter artist name (optional)">
                  </div>
                  <div id="privateCheckContainer" class="form-check" style="display: none;">
                    <input class="form-check-input" type="checkbox" id="newSongPrivate">
                    <label class="form-check-label" for="newSongPrivate">
                      <i class="bi bi-lock"></i> Private Song
                    </label>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Option 2: Use Existing -->
            <div id="existingMatchesContainer" style="display: none;">
              <h6><strong>Use Existing Song</strong></h6>
              <div id="existingMatchesList" class="row g-2"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" id="confirmAddSongBtn" class="btn btn-primary" disabled>Add Song</button>
      </div>
    </div>
  </div>
</div>

<!-- Debug Audio Player (temporarily visible to verify audio loads on Safari) -->
<div class="mb-2" style="background:#f8f9fa; padding:8px; border-radius:6px;">
  <small class="text-muted d-block mb-1">Audio Debug Player</small>
  <audio id="audio" preload="metadata" controls style="width:100%;">
    <!-- Source set dynamically in script -->
</audio>
  <small class="text-muted">If you can hear audio here but no waveform appears, the issue is with waveform init, not audio load.</small>
</div>

<!-- Peaks.js Dependencies -->
<script src="/js/konva.min.js"></script>
<script src="/js/waveform-data.min.js"></script>
<script src="/js/peaks.min.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
      console.log("=== PEAKS.JS SPLIT PAGE STARTING ===");

    // Debug panel removed - use browser console for debugging
    const debugDiv = null;

      function addDebugLog(message) {
      // Just log to console, no visual debug panel
      console.log(message);
    }

      let peaks = null;
      let selectedSegment = null;
      const segmentSongMap = {};
    let peaksInitialized = false;
    let didUnlockAudio = false;
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

      // Real songs from your setlist
      const realSongs = <%- JSON.stringify(
        setlist.sets
          .filter(set => set.name !== 'Maybe')
          .flatMap(set =>
            (set.songs || []).map(setlistSong => ({
              id: setlistSong.song.id,
              title: setlistSong.song.title,
              artist: (setlistSong.song.artists && setlistSong.song.artists.length > 0)
                ? setlistSong.song.artists[0].artist.name
                : 'Unknown'
            }))
          )
      ) %>;

      // Load the actual recording file
      const audioElement = document.getElementById("audio");
      // Prevent page reloads from unhandled errors
      window.addEventListener('error', (e) => {
        console.error('Global error caught:', e.error, e.message, e.filename, e.lineno);
        addDebugLog('Global error: ' + e.message + ' at ' + e.filename + ':' + e.lineno);
        e.preventDefault(); // Prevent default error handling that might cause reload
        return true; // Prevent error from propagating
      });

      window.addEventListener('unhandledrejection', (e) => {
        console.error('Unhandled promise rejection:', e.reason);
        addDebugLog('Unhandled promise rejection: ' + e.reason);
        e.preventDefault(); // Prevent default error handling
      });

      // Send client-side logs to server for debugging Safari reloads
      function sendLogToServer(level, message, data) {
        try {
          const logData = JSON.stringify({
            level: level,
            message: message,
            data: data,
            url: window.location.pathname,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent
          });
          
          // Use sendBeacon for unload events - more reliable than fetch
          if (level === 'warn' && message === 'Page unloading') {
            if (navigator.sendBeacon) {
              const blob = new Blob([logData], { type: 'application/json' });
              navigator.sendBeacon('/bands/api/client-log', blob);
              return;
            }
          }
          
          fetch('/bands/api/client-log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: logData,
            keepalive: true // Important: allows request to complete even if page is unloading
          }).catch(() => {}); // Ignore errors - page might be unloading
        } catch (e) {
          // Ignore - page might be unloading
        }
      }

      // Detect page reloads to help diagnose
      let pageLoadTime = Date.now();
      let unloadReported = false;
      window.addEventListener('beforeunload', (e) => {
        if (unloadReported) return;
        unloadReported = true;
        const timeOnPage = Date.now() - pageLoadTime;
        console.error('Page unloading after', timeOnPage, 'ms');
        addDebugLog('Page unloading after ' + timeOnPage + 'ms - this may be Safari killing the page due to memory');
        sendLogToServer('warn', 'Page unloading', {
          timeOnPage: timeOnPage,
          memoryUsed: performance.memory ? performance.memory.usedJSHeapSize : null,
          memoryLimit: performance.memory ? performance.memory.jsHeapSizeLimit : null
        });
      });

      // Define Safari/iOS detection variables BEFORE using them
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const iosPreferred = isIOS || safari;

      // Log immediately when page loads
      sendLogToServer('info', 'Split page loaded', {
        recordingId: <%= recording.id %>,
        fileSize: <%= recording.fileSize || 0 %>,
        fileSizeMB: <%= recording.fileSize ? (Number(recording.fileSize) / (1024 * 1024)).toFixed(2) : 0 %>,
        safari: safari,
        isIOS: isIOS,
        memoryUsed: performance.memory ? performance.memory.usedJSHeapSize : null,
        memoryLimit: performance.memory ? performance.memory.jsHeapSizeLimit : null,
        pageLoadTime: Date.now()
      });
      
      // Also log periodically to track if page is still alive
      let heartbeatCount = 0;
      const heartbeatInterval = setInterval(() => {
        heartbeatCount++;
        sendLogToServer('info', 'Page heartbeat', {
          heartbeatCount: heartbeatCount,
          timeSinceLoad: Date.now() - pageLoadTime,
          memoryUsed: performance.memory ? performance.memory.usedJSHeapSize : null
        });
      }, 3000); // Every 3 seconds
      
      // Clear interval when page unloads (if beforeunload fires)
      window.addEventListener('beforeunload', () => {
        clearInterval(heartbeatInterval);
      });

      // Prevent Safari from killing the page - keep a reference to prevent garbage collection
      window._keepAlive = {
        audioElement: audioElement,
        timestamp: Date.now()
      };
      const baseUrl = window.location.origin;
      const recordingPath = baseUrl + "<%= recording.filePath %>";
      const iosPathRel = "<%= typeof iosPlaybackPath !== 'undefined' && iosPlaybackPath ? iosPlaybackPath : '' %>";
      const iosPath = iosPathRel ? (baseUrl + iosPathRel) : null;
      let triedIosPath = false;

      // For Safari on large files, defer audio loading until Peaks.js is ready
      // This prevents Safari from trying to load a 90+ MB file immediately on page load
      const fileSizeMB = <%= recording.fileSize ? (Number(recording.fileSize) / (1024 * 1024)).toFixed(2) : 0 %>;
      const isLargeFileSafari = safari && fileSizeMB > 50;
      
      if (isLargeFileSafari) {
        // DON'T set src yet - wait until Peaks.js initializes
        // This prevents Safari from crashing while loading the huge audio file
        sendLogToServer('info', 'Deferring audio load for Safari large file', {
          fileSizeMB: fileSizeMB,
          reason: 'Prevent immediate memory spike from loading large audio file'
        });
        // Will set src later when Peaks.js is ready
      } else {
        // Normal loading for small files or non-Safari browsers
        if (iosPreferred && iosPath) {
          audioElement.src = iosPath;
          triedIosPath = true;
        } else {
          audioElement.src = recordingPath;
        }
      }

      // Add audio event listeners for debugging and fallback
      audioElement.addEventListener("error", (e) => {
        addDebugLog("Audio error: " + e.message);
        // If iOS path failed, try the original WebM
        if (triedIosPath && audioElement.src === iosPath) {
          addDebugLog("iOS path failed, falling back to original WebM");
          audioElement.src = recordingPath;
          triedIosPath = false; // Prevent infinite loop
        }
      });

      // Populate songs list
      const songsList = document.getElementById("songsList");
      let songIndex = 1;
      realSongs.forEach((song) => {
        const div = document.createElement("div");
        div.className = "song-item mb-2 p-2 border rounded";
        div.setAttribute("data-song-id", song.id);
        div.setAttribute("data-song-index", songIndex);
        div.setAttribute("data-song-title", song.title);
        div.style.cssText = "cursor: pointer; transition: background 0.2s;";
        div.innerHTML = `
        <div class="d-flex justify-content-between align-items-center" style="line-height: 1.1;">
          <div style="font-size: 0.85rem;">
              <strong>${songIndex}. ${song.title}</strong>
            </div>
            <span class="badge bg-secondary" id="song-badge-${song.id}" style="display: none;">
              Assigned
            </span>
          </div>
        `;
        div.onclick = () => {
        addDebugLog(`Song clicked: ${song.title}. Current selectedSegment ID: ${selectedSegment ? selectedSegment.id : 'null'}`);
          if (selectedSegment) {
            assignSongToSegment(selectedSegment.id, song.id);
          } else {
            addDebugLog(
            "Please select a segment first by clicking on it in the waveform."
            );
          }
        };
        songsList.appendChild(div);
        songIndex++;
      });

      // Initialize Peaks.js - fix race condition
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          initPeaks();
        });
      } else {
        // DOM is already ready
        initPeaks();
      }

      function initPeaks() {
        const overviewContainer = document.getElementById("overview-container");
        const zoomviewContainer = document.getElementById("zoomview-container");

        addDebugLog("Initializing Peaks.js...");

      // If Safari, show the explicit unlock button near the loader
      const safariUnlock = document.getElementById('safariUnlockContainer');
      const safariLoadBtn = document.getElementById('safariLoadBtn');
      // Show the unlock button as a universal fallback if waveform isn't ready yet
      if (safariUnlock && safariLoadBtn) {
        safariUnlock.style.display = 'block';
        safariLoadBtn.onclick = async () => {
          try {
            // For Safari on large files, audio src is NOT set yet - don't try to play
            if (isLargeFileSafari && !audioElement.src) {
              addDebugLog('Large file Safari - setting audio src and initializing Peaks.js');
              sendLogToServer('info', 'Safari button clicked - loading audio now', {
                fileSizeMB: fileSizeMB
              });
              // NOW set the src and initialize
              if (iosPreferred && iosPath) {
                audioElement.src = iosPath;
                triedIosPath = true;
              } else {
                audioElement.src = recordingPath;
              }
              // Wait a bit for src to be set, then initialize
              setTimeout(() => {
                if (!peaksInitialized) {
                  initializePeaksWithAudio();
                }
              }, 100);
            } else {
              // Normal flow - audio already has src
              await audioElement.play();
              didUnlockAudio = true;
              // Hide the unlock UI after success
              safariUnlock.style.display = 'none';
              if (!peaksInitialized) {
                initializePeaksWithAudio();
              }
            }
          } catch (e) {
            addDebugLog('Unlock button failed: ' + e.message);
            sendLogToServer('error', 'Safari button click failed', { error: e.message });
          }
        };
      }

        // Check if audio is already ready, or wait for it
        // BUT: For Safari large files, audio src is NOT set, so skip this
        if (!isLargeFileSafari) {
        if (audioElement.readyState >= 3) {
          // HAVE_FUTURE_DATA or higher
          initializePeaksWithAudio();
        } else {
          audioElement.addEventListener("canplay", () => {
            initializePeaksWithAudio();
            });
          }
        } else {
          // Safari large file - wait for button click to set src
          addDebugLog('Safari large file - waiting for user to click button to load audio');
          sendLogToServer('info', 'Safari large file - deferred audio loading', {
            fileSizeMB: fileSizeMB,
            reason: 'Waiting for user interaction to load large audio file'
          });
        }
      }

      function initializePeaksWithAudio() {
      if (peaksInitialized) {
        addDebugLog("Peaks.js already initialized - skipping re-initialization");
        return;
      }
        addDebugLog("Starting Peaks.js initialization...");

        const overviewContainer = document.getElementById("overview-container");
        const zoomviewContainer = document.getElementById("zoomview-container");

      // Animate loading bar
      const loadingBar = document.getElementById("loadingBar");
      const loadingStatus = document.getElementById("loadingStatus");
      let progress = 0;
      const updateProgress = setInterval(() => {
        progress += 5;
        if (loadingBar) {
          loadingBar.style.width = Math.min(progress, 95) + '%';
        }
      }, 100);

        //   const options = {
        //     containers: {
        //       overview: overviewContainer,
        //       zoomview: zoomviewContainer,
        //     },
        //     mediaElement: audioElement,
        //     webAudio: {
        //       audioContext: new (window.AudioContext ||
        //         window.webkitAudioContext)(),
        //     },
        //     segments: [],
        //   };o

        addDebugLog("Calling Peaks.init()...");
        //   const PeaksLib = window.peaks || window.Peaks;
        //   addDebugLog("Using PeaksLib: " + typeof PeaksLib);

        // Fix container dimensions - ensure they have width and are visible
        overviewContainer.style.width = "100%";
        overviewContainer.style.minHeight = "100px";
        overviewContainer.style.display = "block";
        zoomviewContainer.style.width = "100%";
        zoomviewContainer.style.minHeight = "200px";
        zoomviewContainer.style.display = "block";

        // Use the working approach from prototype2
        const PeaksLib = window.peaks || window.Peaks;

      // Determine waveform source
      let waveformSource;
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const forceFullDetail = <%= typeof fullMode !== 'undefined' && fullMode ? 'true' : 'false' %>;
      <% if (typeof useWebAudio !== 'undefined' && useWebAudio) { %>
      waveformSource = {
        webAudio: {
          audioContext: new (window.AudioContext || window.webkitAudioContext)(),
          scale: 2048,
          multiChannel: false
        }
      };
      <% } else if (typeof waveformZoomLevels !== 'undefined' && waveformZoomLevels && Object.keys(waveformZoomLevels).length > 0) { %>
      // Check for progressive zoom levels (using waveformZoomLevels)
      <% 
      const zoomLevels = typeof waveformZoomLevels !== 'undefined' && waveformZoomLevels ? waveformZoomLevels : {};
      const hasProgressiveZoom = zoomLevels && Object.keys(zoomLevels).length >= 2;
      const hasSingleZoom = zoomLevels && Object.keys(zoomLevels).length === 1;
      
      // Note: Safari detection happens client-side below, not in EJS
      %>
      // Debug logging (client-side)
      addDebugLog('[TEMPLATE] waveformZoomLevels: ' + <%- JSON.stringify(waveformZoomLevels) %>);
      addDebugLog('[TEMPLATE] zoomLevels: ' + <%- JSON.stringify(zoomLevels) %>);
      addDebugLog('[TEMPLATE] hasProgressiveZoom: ' + <%- JSON.stringify(hasProgressiveZoom) %>);
      addDebugLog('[TEMPLATE] hasSingleZoom: ' + <%- JSON.stringify(hasSingleZoom) %>);
      addDebugLog('[TEMPLATE] zoomLevels[1]: ' + <%- JSON.stringify(zoomLevels[1]) %>);
      <% if (hasProgressiveZoom) { %>
      // Use progressive zoom levels (loads lowest first, higher on zoom)
      // For desktop: levels 64, 128, 256, 512 samples/pixel
      // Note: Even though level 4 is 512, we'll let Peaks.js handle it
      // but we need to ensure zoomLevels option prevents resampling to 512
      const baseUrl = window.location.origin;
      waveformSource = {
        dataUri: {
          <% if (zoomLevels[1]) { %>1: baseUrl + "<%= zoomLevels[1] %>",<% } %>
          <% if (zoomLevels[2]) { %>2: baseUrl + "<%= zoomLevels[2] %>",<% } %>
          <% if (zoomLevels[3]) { %>3: baseUrl + "<%= zoomLevels[3] %>",<% } %>
          <% if (zoomLevels[4]) { %>4: baseUrl + "<%= zoomLevels[4] %>"<% } %>
        }
      };
      addDebugLog("Using progressive zoom levels: " + <%- JSON.stringify(Object.keys(zoomLevels)) %>);
      addDebugLog("Mobile device detected: " + isMobile + ", starting with lowest resolution");
      // Note: For progressive zoom, we'll set zoomLevels in options to prevent resampling below 2048
      <% } %>
      <% if (!hasProgressiveZoom && hasSingleZoom && zoomLevels[1]) { %>
      // Use single zoom level (mobile or Safari on large files)
      const baseUrl = window.location.origin;
      <% 
      // Determine scale based on whether this is Safari large file (8192) or mobile (1024)
      const isSafariLarge = typeof isSafariLargeFile !== 'undefined' && isSafariLargeFile;
      const singleZoomScale = isSafariLarge ? 8192 : 1024;
      %>
      waveformSource = {
        dataUri: {
          arraybuffer: baseUrl + "<%= zoomLevels[1] %>",
          scale: <%= singleZoomScale %>
        }
      };
      addDebugLog("Using single zoom level: " + <%- JSON.stringify(Object.keys(zoomLevels)) %> + " (scale: <%= singleZoomScale %> samples/pixel)");
      addDebugLog("Single zoom URL: " + baseUrl + "<%= zoomLevels[1] %>");
      <% } %>
      <% if (!hasProgressiveZoom && !hasSingleZoom && typeof recording !== 'undefined' && recording.waveformPath) { %>
      // Fallback to single waveform file
      waveformSource = {
        dataUri: {
          arraybuffer: "<%= recording.waveformPath %>",
          scale: 2048
        }
      };
      addDebugLog("Using single waveform file: <%= recording.waveformPath %>");
      <% } %>
      <% if (!hasProgressiveZoom && !hasSingleZoom && (typeof recording === 'undefined' || !recording.waveformPath)) { %>
      // No waveform files available - using Web Audio as fallback (inside waveformZoomLevels block)
      addDebugLog("WARNING: No .dat files or waveformPath available, falling back to Web Audio");
      addDebugLog("waveformZoomLevels was: " + <%- JSON.stringify(waveformZoomLevels) %>);
      // Use higher scale (2048) to meet Peaks.js minimum requirement
      waveformSource = {
        webAudio: {
          audioContext: new (window.AudioContext || window.webkitAudioContext)(),
          scale: 2048,
          multiChannel: false
        }
      };
      <% } %>
      <% } %>
      <% if (typeof waveformZoomLevels === 'undefined' || !waveformZoomLevels || Object.keys(waveformZoomLevels).length === 0) { %>
      // No waveformZoomLevels at all - use Web Audio fallback
      waveformSource = {
        webAudio: {
          audioContext: new (window.AudioContext || window.webkitAudioContext)(),
          scale: 2048,
          multiChannel: false
        }
      };
      <% } %>

      // Log memory usage and waveform configuration
      if (typeof performance !== 'undefined' && performance.memory) {
        const memoryMB = (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(2);
        const limitMB = (performance.memory.jsHeapSizeLimit / (1024 * 1024)).toFixed(2);
        addDebugLog("Browser memory usage: " + memoryMB + " MB / " + limitMB + " MB limit");
      }
      if (typeof navigator !== 'undefined' && navigator.deviceMemory) {
        addDebugLog("Device memory: " + navigator.deviceMemory + " GB");
      }
      
      // Log waveform source configuration
      if (waveformSource && waveformSource.dataUri) {
        const levels = waveformSource.dataUri;
        const levelKeys = Object.keys(levels).filter(k => k !== 'arraybuffer' && k !== 'scale');
        addDebugLog("Using Peaks.js with .dat files - zoom levels: " + (levelKeys.length > 0 ? levelKeys.join(', ') : 'single level'));
        if (levels.scale) {
          addDebugLog("Single zoom level scale: " + levels.scale + " samples/pixel");
        }
      } else if (waveformSource && waveformSource.webAudio) {
        addDebugLog("Using Peaks.js with Web Audio API (generates waveform on-the-fly)");
      }

        // For .dat files, we need to set zoomLevels to prevent Peaks.js from trying to resample
        // at invalid zoom levels (below 2048). The zoom levels should match the actual data scales.
        const options = {
          overview: {
            container: overviewContainer,
          },
          zoomview: {
            container: zoomviewContainer,
            // Disable default click-to-seek behavior that resets zoom
            axisGridlineColor: "#ccc",
            axisLabelColor: "#000",
            // Try to prevent auto-scrolling during segment drag
            playheadColor: "#f00",
            playheadTextColor: "#000",
            // Enable scrollbar when zoomed in
            enableScrollbar: true,
          showSegmentLabels: true,
          // CRITICAL: Disable Peaks.js's built-in mouse interactions
          enableMarkerEditing: false,
          enableSegmentDragging: false
          },
          mediaElement: audioElement,
        ...waveformSource,
          segments: [],
          // Disable default keyboard shortcuts that might interfere
          keyboard: false,
          // Disable default point editing
          pointMarkerColor: "#ff0000",
        // Disable segment dragging to prevent interference with our custom segment creation
        segmentOptions: {
          markers: false
        }
        };
        
        // Set zoomLevels based on the waveform source type
        if (waveformSource && waveformSource.webAudio) {
          // Web Audio mode - all levels must be >= 2048
          options.zoomLevels = [2048, 4096, 8192, 16384];
        } else if (waveformSource && waveformSource.dataUri) {
          // For .dat files, set zoomLevels to match the actual data scales
          // This prevents Peaks.js from trying to resample at invalid levels
          if (waveformSource.dataUri.scale) {
            // Single zoom level - set explicit zoom levels to prevent Peaks.js from resampling below 2048
            const scale = waveformSource.dataUri.scale;
            addDebugLog("Single zoom level detected with scale: " + scale);
            if (scale >= 8192) {
              // Safari large file - use the actual scale and higher, but ensure all >= 2048
              options.zoomLevels = [2048, 4096, 8192];
            } else if (scale >= 4096) {
              options.zoomLevels = [2048, 4096, 8192];
            } else if (scale >= 2048) {
              options.zoomLevels = [2048, 4096, 8192];
            } else {
              // Scale is too low (e.g., 1024 for mobile) - force minimum valid levels
              // Peaks.js will use the data but won't try to resample below 2048
              options.zoomLevels = [2048, 4096, 8192];
            }
            addDebugLog("Setting zoomLevels for single zoom: " + JSON.stringify(options.zoomLevels) + " (data scale: " + scale + ")");
          } else if (Object.keys(waveformSource.dataUri).filter(k => k !== 'arraybuffer' && k !== 'scale').length > 0) {
            // Progressive zoom levels (desktop: levels 1=64, 2=128, 3=256, 4=512 samples/pixel)
            // Peaks.js minimum is 2048, so we need to prevent it from resampling to lower levels
            // Set explicit zoom levels that are all >= 2048
            // Even though the data has 512, we'll prevent Peaks.js from using it directly
            const availableLevels = Object.keys(waveformSource.dataUri).filter(k => k !== 'arraybuffer' && k !== 'scale');
            addDebugLog("Progressive zoom levels available: " + availableLevels.join(', '));
            // Force Peaks.js to use only valid zoom levels (>= 2048)
            // This prevents it from trying to resample at 512 or other invalid levels
            options.zoomLevels = [2048, 4096, 8192];
            addDebugLog("Setting zoomLevels to prevent resampling below 2048: " + JSON.stringify(options.zoomLevels));
          } else {
            // Fallback - no recognized dataUri structure, set safe zoom levels
            options.zoomLevels = [2048, 4096, 8192];
            addDebugLog("Fallback: Setting zoomLevels to prevent resampling below 2048: " + JSON.stringify(options.zoomLevels));
          }
        } else {
          // No waveform source - set safe defaults
          options.zoomLevels = [2048, 4096, 8192];
          addDebugLog("No waveform source - setting safe zoomLevels: " + JSON.stringify(options.zoomLevels));
        }

        sendLogToServer('info', 'Starting Peaks.js initialization', {
          waveformSourceType: waveformSource.dataUri ? 'dat' : (waveformSource.webAudio ? 'webAudio' : 'unknown'),
          hasProgressiveZoom: waveformSource.dataUri && Object.keys(waveformSource.dataUri).length > 1
        });

        PeaksLib.init(options, (err, p) => {
          if (err) {
            console.error("Failed to initialize Peaks.js:", err);
            addDebugLog("Peaks.js init error: " + err.message);
            addDebugLog("Full error: " + JSON.stringify(err));
            addDebugLog("Error stack: " + (err.stack || 'No stack'));
            addDebugLog("Options used: " + JSON.stringify(options));
            
            sendLogToServer('error', 'Peaks.js initialization failed', {
              error: err.message,
              stack: err.stack
            });
            
            // Don't reload - show error and allow fallback
            showError("Failed to initialize waveform editor: " + err.message + ". The page will not reload. Please try refreshing manually if needed.");
            
            // Try to prevent any automatic reload attempts
            if (typeof window.stop === 'function') {
              window.stop();
            }
            
            return;
          }

          peaks = p;
          console.log("Peaks.js initialized successfully");
          addDebugLog("Peaks.js initialized successfully!");
          sendLogToServer('info', 'Peaks.js initialized successfully', {});
          
          // NOW load the audio file (if we deferred it for Safari large files)
          if (isLargeFileSafari && !audioElement.src) {
            sendLogToServer('info', 'Loading audio file now (after Peaks.js init)', {
              fileSizeMB: fileSizeMB
            });
            if (iosPreferred && iosPath) {
              audioElement.src = iosPath;
              triedIosPath = true;
            } else {
              audioElement.src = recordingPath;
            }
          }
          
        peaksInitialized = true; // Mark as initialized to prevent re-initialization

        // Complete loading animation
        if (loadingBar) {
          loadingBar.style.width = '100%';
          clearInterval(updateProgress);
        }
        if (loadingStatus) {
          loadingStatus.textContent = 'Ready!';
        }

          // Hide loading progress and show waveform
        setTimeout(() => {
          document.getElementById("loadingProgress").style.display = "none";
        }, 300);
          overviewContainer.style.display = "block";
          zoomviewContainer.style.display = "block";

          // Set up controls
          setupControls();
          setupSegmentEvents();

          // Initialize process button state
          updateProcessButton();

          // Set initial zoom to show whole file
          const zoomview = peaks.views.getView("zoomview");
          const scrollbar = peaks.views.getScrollbar();
          zoomview.setZoom({ seconds: "auto" });
          document.getElementById("zoom").value = 0; // Slider at left = auto
          // Hide scrollbar initially (zoomed out)
          if (scrollbar) {
            scrollbar.hide();
          }

          // Update total time
          document.getElementById("totalTime").textContent = formatTime(
            Math.floor(audioElement.duration)
          );

        // Enable click-to-seek on the waveform
        setTimeout(() => {
          // Re-enable pointer events on canvases to allow click-to-seek
          const allCanvases = zoomviewContainer.querySelectorAll('canvas');
          allCanvases.forEach((canvas) => {
            canvas.style.pointerEvents = 'auto';
          });
          
          // Add click handler for seeking
          const zoomview = peaks.views.getView("zoomview");
          if (zoomview && zoomview.view) {
            zoomview.view.on('stage:click', (e) => {
              // Only seek if not clicking on a segment
              const target = e.evt.target;
              if (target && target.parent && target.parent.className === 'segment') {
                return; // Don't seek if clicking on a segment label
              }
              
              const x = e.evt.clientX - e.target.getStage().container().getBoundingClientRect().left;
              const seekTime = peaks.time.getScaledTime(x);
              
              if (seekTime !== null && seekTime !== undefined) {
                peaks.player.seek(seekTime);
              }
            });
          }
        }, 100);

          addDebugLog("Setup complete!");

        // Enable auto-detect button
        document.getElementById('autoDetectBtn').disabled = false;
        });
      }

      // Handle audio errors
      audioElement.addEventListener("error", (e) => {
        console.error("Audio loading error:", e);
        addDebugLog("Audio error: " + e.message);
        showError("Failed to load audio file: " + recordingPath);
      });

      // Setup UI controls
      let controlsSetup = false;
      function setupControls() {
        if (controlsSetup) {
          return;
        }
        controlsSetup = true;

        // Play/Pause button
        const playBtn = document.getElementById("playPauseBtn");
        if (playBtn) {
          let isProcessing = false; // Prevent rapid clicks
          playBtn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();

            if (isProcessing) {
              addDebugLog("Click ignored - already processing");
              return;
            }

            isProcessing = true;
            // Safari user-gesture unlock: attempt once on first interaction
            if (isSafari && !didUnlockAudio) {
              try {
                await audioElement.play();
                didUnlockAudio = true;
                if (!peaksInitialized) {
                  addDebugLog("Post-unlock Peaks init");
                  initializePeaksWithAudio();
                }
              } catch (unlockErr) {
                addDebugLog("Unlock failed: " + unlockErr.message);
              }
            }
            addDebugLog("Button clicked - paused: " + audioElement.paused);

            try {
              if (audioElement.paused) {
                addDebugLog("Calling audioElement.play()");
                await audioElement.play();
                playBtn.innerHTML = '<i class="bi bi-pause-fill"></i> Pause';
                addDebugLog("Play successful");
              } else {
                addDebugLog("Calling audioElement.pause()");
                audioElement.pause();
                playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
                addDebugLog("Pause successful");
              }
            } catch (error) {
              addDebugLog("Play error: " + error.message);
              playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
            } finally {
              // Reset processing flag after a short delay
              setTimeout(() => {
                isProcessing = false;
              }, 100);
            }
          });
        }

        // Stop button
        const stopBtn = document.getElementById("stopBtn");
        if (stopBtn) {
          stopBtn.addEventListener("click", () => {
            audioElement.pause();
            audioElement.currentTime = 0;
            playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
          });
        }

      // Zoom control
      const zoomSlider = document.getElementById("zoom");
      if (zoomSlider) {
        zoomSlider.addEventListener("input", (e) => {
          const sliderValue = Number(e.target.value);
          const zoomview = peaks.views.getView("zoomview");
          const scrollbar = peaks.views.getScrollbar();

          if (sliderValue === 0) {
            // Slider at left = auto (show whole file)
            zoomview.setZoom({ seconds: "auto" });
            // Hide scrollbar when zoomed out
            scrollbar?.hide();
          } else {
            // Slider at right = show fewer seconds (more zoomed in)
            const totalDuration = audioElement.duration;
            const secondsToShow =
              totalDuration - (sliderValue / 100) * (totalDuration - 1);
            zoomview.setZoom({ seconds: secondsToShow });
            // Show scrollbar when zoomed in
            scrollbar?.show();
          }
        });
      }

      // Reset zoom
      document.getElementById("resetZoomBtn").addEventListener("click", () => {
        const zoomview = peaks.views.getView("zoomview");
        const scrollbar = peaks.views.getScrollbar();
        zoomview.setZoom({ seconds: "auto" });
        document.getElementById("zoom").value = 0;
        // Hide scrollbar when resetting to auto zoom
        scrollbar?.hide();
      });
      }

      // Setup Peaks.js segment events
      let segmentEventsSetup = false;
      function setupSegmentEvents() {
        if (segmentEventsSetup) {
          return;
        }
        segmentEventsSetup = true;

        // Enable segment creation by dragging
        peaks.on("segments.add", (segment) => {
        // This event is for segments created via the UI, which we have customized.
        // The main logic is now handled manually after creation.
        });

        // Update time display using native audio element
        audioElement.addEventListener("timeupdate", () => {
          document.getElementById("currentTime").textContent = formatTime(audioElement.currentTime);
        });

        // Don't add play/pause event listeners - button handler updates manually
        // This prevents duplicate event handling

        // Monitor zoom changes and prevent unwanted resets
        let zoomCheckInterval = null;
        const startZoomMonitoring = () => {
          if (zoomCheckInterval) return;
          zoomCheckInterval = setInterval(() => {
            try {
              const zoomview = peaks.views.getView("zoomview");
              const startTime = zoomview.getStartTime();
              const endTime = zoomview.getEndTime();
              const visibleDuration = endTime - startTime;

              // If zoom suddenly changes to auto (full duration), restore it
              if (currentZoomSeconds && visibleDuration >= audioElement.duration * 0.99) {
                const sliderValue = document.getElementById("zoom").value;
                if (sliderValue != 0) {
                  addDebugLog("Detected zoom reset - restoring");
                  restoreZoomIfNeeded();
                }
              }
            } catch (err) {
              // Ignore errors - zoom monitoring may fail if Peaks.js not ready
            }
          }, 100);
        };

        // Start monitoring after initial setup
        setTimeout(() => {
          startZoomMonitoring();
        }, 1000);

        // Prevent zoom reset - store current zoom state
        let currentZoomSeconds = null;

        // Store current zoom before any interaction
        function storeCurrentZoom() {
          try {
            const zoomview = peaks.views.getView("zoomview");
            const startTime = zoomview.getStartTime();
            const endTime = zoomview.getEndTime();
            const visibleDuration = endTime - startTime;
            if (visibleDuration > 0 && visibleDuration < audioElement.duration) {
              currentZoomSeconds = visibleDuration;
              addDebugLog("Stored zoom: " + currentZoomSeconds.toFixed(1) + " seconds");
          } else {
             addDebugLog("Did not store zoom. Visible duration: " + visibleDuration);
            }
          } catch (err) {
          addDebugLog("Error in storeCurrentZoom: " + err.message);
          }
        }

        // Restore zoom if it gets reset
        function restoreZoomIfNeeded() {
        addDebugLog(`restoreZoomIfNeeded called. Stored zoom is: ${currentZoomSeconds ? currentZoomSeconds.toFixed(1) : 'null'}`);
          if (currentZoomSeconds && currentZoomSeconds < audioElement.duration) {
            try {
              const sliderValue = document.getElementById("zoom").value;
              if (sliderValue != 0) {
                // Only restore if zoom slider is not at 0 (auto)
                const zoomview = peaks.views.getView("zoomview");
                zoomview.setZoom({ seconds: currentZoomSeconds });
                addDebugLog("Restored zoom to: " + currentZoomSeconds.toFixed(1) + " seconds");
              }
            } catch (err) {
              // Ignore errors
            }
          }
        }

        // Enable segment creation by dragging and prevent zoom reset
        const zoomviewContainer = document.getElementById("zoomview-container");
        let isDragging = false;
        let dragStart = null;
        let dragStartX = null;
      let isPanning = false;
      let panStartX = null;
      let tempSegment = null;
      let isPreparingToDrag = false;
      let isResizing = false;
      let resizeSegment = null;
      let resizeEdge = null; // 'start' or 'end'

      // Helper function to check if clicking near a segment edge
      function findSegmentEdgeAtTime(time, tolerance = 2) {
        const segments = peaks.segments.getSegments();
        for (const segment of segments) {
          const startDiff = Math.abs(segment.startTime - time);
          const endDiff = Math.abs(segment.endTime - time);

          if (startDiff < tolerance) {
            return { segment, edge: 'start' };
          } else if (endDiff < tolerance) {
            return { segment, edge: 'end' };
          }
        }
        return null;
      }

      // Helper function to find segment at a given time (for selection)
      function findSegmentAtTime(time) {
        const segments = peaks.segments.getSegments();
        for (const segment of segments) {
          if (time >= segment.startTime && time <= segment.endTime) {
            return segment;
          }
        }
        return null;
      }

      // Helper function to get clientX from mouse or touch events
      const getClientX = (e) => {
        if (e.touches && e.touches.length > 0) {
          return e.touches[0].clientX;
        }
        if (e.changedTouches && e.changedTouches.length > 0) {
          return e.changedTouches[0].clientX;
        }
        return e.clientX;
      };

      // Define drag handlers before they're referenced
      const handleDragMove = (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (isResizing && resizeSegment) {
          // Handle segment resizing
          isDragging = true;
            const rect = zoomviewContainer.getBoundingClientRect();
            const x = getClientX(e) - rect.left;
            const zoomview = peaks.views.getView("zoomview");

              const startTime = zoomview.getStartTime();
              const endTime = zoomview.getEndTime();
              const visibleDuration = endTime - startTime;
          const width = zoomviewContainer.offsetWidth;
          const currentTime = startTime + (x / width) * visibleDuration;

          // Update the segment's start or end time
          if (resizeEdge === 'start') {
            if (currentTime < resizeSegment.endTime) {
              resizeSegment.update({ startTime: currentTime });
            }
          } else if (resizeEdge === 'end') {
            if (currentTime > resizeSegment.startTime) {
              resizeSegment.update({ endTime: currentTime });
            }
          }

        } else if (dragStart !== null) {
          // Handle new segment creation
              isDragging = true;
            const rect = zoomviewContainer.getBoundingClientRect();
            const x = getClientX(e) - rect.left;
            const zoomview = peaks.views.getView("zoomview");

          // Manual calculation since pointer events are disabled on canvas
              const startTime = zoomview.getStartTime();
              const endTime = zoomview.getEndTime();
              const visibleDuration = endTime - startTime;
          const width = zoomviewContainer.offsetWidth;
          const currentTime = startTime + (x / width) * visibleDuration;

              const segmentStart = Math.min(dragStart, currentTime);
              const segmentEnd = Math.max(dragStart, currentTime);

          if (isPreparingToDrag) {
            isPreparingToDrag = false;
            // Create the temp segment on the first mouse move
            try {
              const result = peaks.segments.add({
                  startTime: segmentStart,
                endTime: segmentEnd,
                id: 'temp-drag-segment',
                color: 'rgba(0, 123, 255, 0.3)',
                editable: false
              });

              // Handle both array and single object return types
              if (Array.isArray(result) && result.length > 0) {
                tempSegment = result[0];
              } else if (result && typeof result === 'object' && result.id) {
                tempSegment = result;
              } else {
                addDebugLog("Error: peaks.segments.add returned unexpected format");
              }
            } catch (err) {
              addDebugLog("Error creating temp segment: " + err.message);
            }
          } else if (tempSegment) {
            // Update the existing temp segment
            try {
              tempSegment.update({
                    startTime: segmentStart,
                endTime: segmentEnd
                  });
                } catch (err) {
              addDebugLog("Error updating temp segment: " + err.message);
            }
          }
        }
      };

      const handleDragEnd = (e) => {
        window.removeEventListener('mousemove', handleDragMove);
        window.removeEventListener('mouseup', handleDragEnd);
        window.removeEventListener('touchmove', handleDragMove);
        window.removeEventListener('touchend', handleDragEnd);

        if (isResizing && resizeSegment) {
          // Resize complete
          zoomviewContainer.style.cursor = 'default';
          updateSegmentList();
          isResizing = false;
          resizeSegment = null;
          resizeEdge = null;
        } else if (isDragging && tempSegment) {
          // Only create permanent segment if we actually dragged
          const startTime = tempSegment.startTime;
          const endTime = tempSegment.endTime;
          const segmentDuration = endTime - startTime;

          // Check minimum segment length (10 seconds)
          if (segmentDuration < 10) {
            addDebugLog(`Segment too short (${segmentDuration.toFixed(2)}s). Minimum is 10 seconds. Segment not created.`);
            // Remove the temporary segment
            peaks.segments.removeById('temp-drag-segment');
            tempSegment = null;
            return;
          }

          // Remove the temporary segment
          peaks.segments.removeById('temp-drag-segment');

          // Create the final permanent segment
          const result = peaks.segments.add({
            startTime: startTime,
            endTime: endTime,
            labelText: "",
            color: '#007bff',
            editable: true
          });

          const finalSegment = Array.isArray(result) ? result[0] : result;

          if (!finalSegment) {
            addDebugLog('ERROR: Failed to create segment!');
            return;
          }

          addDebugLog(`Created segment: ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s`);

          // Auto-select the new segment
          if (selectedSegment) {
            const oldAssignment = segmentSongMap[selectedSegment.id];
            selectedSegment.update({ color: oldAssignment ? '#28a745' : '#007bff' });
          }
          selectedSegment = finalSegment;
          selectedSegment.update({ color: '#ffc107' });
          updateSelectedSegmentInfo();
          updateSegmentList();
          updateProcessButton();

          tempSegment = null;

        } else if (dragStart !== null && !isDragging) {
            // This was a click, not a drag. Seek the playhead.
            peaks.player.seek(dragStart);
        }

        // Always clean up temp segment if it exists but wasn't converted
              if (tempSegment) {
                try {
            peaks.segments.removeById('temp-drag-segment');
            addDebugLog("Cleaned up leftover temp segment");
                } catch (err) {
            // Ignore if already removed
                }
                tempSegment = null;
        }

        // Restore zoom after interaction
        setTimeout(() => {
          restoreZoomIfNeeded();
        }, 100);

        // Reset all drag-related state
            isDragging = false;
            dragStart = null;
            dragStartX = null;
        isPreparingToDrag = false;
      };

      const handlePanMove = (e) => {
        if (!isPanning) return;
        const clientX = getClientX(e);
        const dx = clientX - panStartX;
        const zoomview = peaks.views.getView("zoomview");
        const duration = zoomview.getEndTime() - zoomview.getStartTime();
        const pixelsPerSecond = zoomviewContainer.offsetWidth / duration;
        const timeOffset = dx / pixelsPerSecond;
        zoomview.setStartTime(zoomview.getStartTime() - timeOffset);
        panStartX = clientX;
        e.preventDefault();
      };

      const handlePanEnd = (e) => {
        if (isPanning) {
          isPanning = false;
          zoomviewContainer.style.cursor = "default";
          window.removeEventListener("mousemove", handlePanMove);
          window.removeEventListener("mouseup", handlePanEnd);
          window.removeEventListener("touchmove", handlePanMove);
          window.removeEventListener("touchend", handlePanEnd);
          e.preventDefault();
        }
      };

      // Prevent overview clicks from resetting zoom
      const overviewContainer = document.getElementById("overview-container");
      const handleOverviewDown = (e) => {
        storeCurrentZoom();
        // Use a timeout to restore the zoom after Peaks.js has finished its default action
            setTimeout(() => {
              restoreZoomIfNeeded();
        }, 50);
      };
      overviewContainer.addEventListener("mousedown", handleOverviewDown);
      overviewContainer.addEventListener("touchstart", handleOverviewDown);

      // Helper function to handle touch/mouse down events
      const handlePointerDown = (e) => {
        // Check for pan mode (Option/Alt key - desktop only)
        if (e.altKey) {
          isPanning = true;
          panStartX = getClientX(e);
          zoomviewContainer.style.cursor = "grabbing";
          window.addEventListener("mousemove", handlePanMove);
          window.addEventListener("mouseup", handlePanEnd);
          window.addEventListener("touchmove", handlePanMove);
          window.addEventListener("touchend", handlePanEnd);
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        // CRITICAL: Prevent Peaks.js default click handler and drag-to-scroll
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation(); // Also prevent other handlers on same element

        // Store current zoom before interaction
        storeCurrentZoom();

        // Calculate click/touch position and time
        const rect = zoomviewContainer.getBoundingClientRect();
        const x = getClientX(e) - rect.left;
        const zoomview = peaks.views.getView("zoomview");

        // Convert pixel position to time
        const startTime = zoomview.getStartTime();
        const endTime = zoomview.getEndTime();
        const visibleDuration = endTime - startTime;
        const width = zoomviewContainer.offsetWidth;
        const time = startTime + (x / width) * visibleDuration;

        // Check if clicking near a segment edge for resizing
        const edgeInfo = findSegmentEdgeAtTime(time);

        if (edgeInfo) {
          // Start resizing
          isResizing = true;
          resizeSegment = edgeInfo.segment;
          resizeEdge = edgeInfo.edge;
          isDragging = false;
          dragStart = null;
          zoomviewContainer.style.cursor = 'ew-resize';
          window.addEventListener('mousemove', handleDragMove);
          window.addEventListener('mouseup', handleDragEnd);
          window.addEventListener('touchmove', handleDragMove);
          window.addEventListener('touchend', handleDragEnd);
        } else {
          // Check if clicking inside a segment (for selection)
          const clickedSegment = findSegmentAtTime(time);

          if (clickedSegment) {
            // Select the segment
            // Deselect previous segment
            if (selectedSegment) {
              const oldAssignment = segmentSongMap[selectedSegment.id];
              selectedSegment.update({ color: oldAssignment ? '#28a745' : '#007bff' });
            }

            // Select new segment
            selectedSegment = clickedSegment;
            selectedSegment.update({ color: '#ffc107' }); // Highlight yellow
            updateSelectedSegmentInfo();
            updateSegmentList();
          } else {
            // Start segment creation (clicked on empty waveform)
            isPreparingToDrag = true;
            isDragging = false;
            dragStart = time;
            dragStartX = x;
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('mouseup', handleDragEnd);
            window.addEventListener('touchmove', handleDragMove);
            window.addEventListener('touchend', handleDragEnd);
          }
          }
      };

      // Use event capturing to intercept BEFORE Peaks.js handlers
      // Support both mouse and touch events
      zoomviewContainer.addEventListener("mousedown", handlePointerDown);
      zoomviewContainer.addEventListener("touchstart", handlePointerDown, { passive: false });
      }

      // Update the list of segments in the UI
      function updateSegmentList() {
        const segmentsList = document.getElementById("segmentsList");
        const segments = peaks.segments.getSegments();

        if (segments.length === 0) {
          segmentsList.innerHTML =
            '<p class="text-muted">No segments created yet. Drag on the waveform to create segments.</p>';
          return;
        }

        let html = '<div class="list-group">';
        segments.forEach((segment, index) => {
          const assignment = segmentSongMap[segment.id];
          const songTitle = assignment
            ? assignment.songTitle
            : "No song assigned";

          html += `
                  <div class="list-group-item d-flex justify-content-between align-items-center ${selectedSegment && selectedSegment.id === segment.id ? 'active' : ''}">
                        <div>
                            <strong>Segment ${index + 1}</strong><br>
                            <small class="text-muted">${formatTime(segment.startTime)} - ${formatTime(segment.endTime)}</small><br>
                            <small class="text-info">${songTitle}</small>
                        </div>
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteSegment('${segment.id}')">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                `;
        });
        html += "</div>";

        segmentsList.innerHTML = html;
      }

      // Update info panel for the selected segment
      function updateSelectedSegmentInfo() {
        const infoDiv = document.getElementById("selectedSegmentInfo");

        if (!selectedSegment) {
        infoDiv.innerHTML = '<p class="mb-0">No segment selected</p>';
          return;
        }

        const assignment = segmentSongMap[selectedSegment.id];
      const songTitle = assignment ? `Assigned: ${assignment.songTitle}` : "No song assigned";

        infoDiv.innerHTML = `
        <div>
            <div>${formatTime(selectedSegment.startTime)} - ${formatTime(selectedSegment.endTime)}</div>
            <div class="small text-info">${songTitle}</div>
                </div>
            `;
      }

    // Helper functions
      function deleteSegment(segmentId) {
        const segment = peaks.segments.getSegment(segmentId);
        if (!segment) return;

        // If the segment had a song, make that song available again in the UI
        const assignment = segmentSongMap[segmentId];
        if (assignment) {
          const songItem = document.querySelector(`[data-song-id="${assignment.songId}"]`);
          if (songItem) {
            songItem.style.display = 'block';
          }
        }

        peaks.segments.removeById(segmentId);
        delete segmentSongMap[segmentId];

        if (selectedSegment && selectedSegment.id === segmentId) {
          selectedSegment = null;
        }

        updateSegmentList();
        updateSelectedSegmentInfo();
        updateProcessButton();
      }

      function undoLastRegion() {
        const segments = peaks.segments.getSegments();
        if (segments.length === 0) {
          addDebugLog("No segments to undo");
          return;
        }

        // Remove the last segment
        const lastSegment = segments[segments.length - 1];
        deleteSegment(lastSegment.id);
        addDebugLog(`Removed last segment: ${lastSegment.id}`);
      }

      async function autoDetectSilence() {
        if (!peaks) {
          alert('Peaks.js is not initialized yet');
          return;
        }

        // Show spinner and disable button
        const autoDetectBtn = document.getElementById('autoDetectBtn');
        const autoDetectSpinner = document.getElementById('autoDetectSpinner');
        autoDetectBtn.disabled = true;
        autoDetectSpinner.style.display = 'inline-block';

        addDebugLog('Starting auto-detect silence...');
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch(audioElement.src);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        const duration = audioBuffer.duration;

        addDebugLog(`Analyzing audio: ${duration.toFixed(2)}s, ${sampleRate}Hz, ${channelData.length} samples`);

        // Parameters for silence detection
        const silenceThreshold = -35; // dB threshold for silence (anything below -35 dB is considered silence)
        const minSilenceDuration = 5.0; // Minimum 5 seconds of silence
        const windowSize = Math.floor(sampleRate * 0.2); // 0.2 second windows

        const silenceRegions = [];
        let inSilence = false;
        let silenceStart = 0;

        // Analyze audio in windows
        for (let i = 0; i < channelData.length - windowSize; i += windowSize) {
          let sumSquares = 0;
          let count = 0;

          for (let j = 0; j < windowSize && i + j < channelData.length; j++) {
            const sample = channelData[i + j];
            sumSquares += sample * sample;
            count++;
          }

          // Calculate RMS
          const rms = Math.sqrt(sumSquares / count);
          // Convert to dB
          const dbValue = 20 * Math.log10(rms + 1e-10);
          const time = i / sampleRate;

          if (dbValue < silenceThreshold) {
            if (!inSilence) {
              inSilence = true;
              silenceStart = time;
            }
          } else {
            if (inSilence) {
              const silenceDuration = time - silenceStart;
              if (silenceDuration >= minSilenceDuration) {
                silenceRegions.push({ start: silenceStart, end: time });
              }
              inSilence = false;
            }
          }
        }

        if (inSilence) {
          const silenceDuration = duration - silenceStart;
          if (silenceDuration >= minSilenceDuration) {
            silenceRegions.push({ start: silenceStart, end: duration });
          }
        }

        addDebugLog(`Found ${silenceRegions.length} silence regions`);

        // Create segments between silence gaps with 2 second buffer on each side
        const bufferTime = 2.0; // 2 seconds buffer before and after each segment
        let startTime = 0;
        let segmentsCreated = 0;
        for (const silence of silenceRegions) {
          // Only create a segment if there's at least 0.5 seconds between start and silence
          if (silence.start - startTime >= 0.5) {
            // Add buffer: start 2 seconds earlier, end 2 seconds later
            const segmentStart = Math.max(0, startTime - bufferTime);
            const segmentEnd = Math.min(duration, silence.start + bufferTime);
            const segmentDuration = segmentEnd - segmentStart;

            // Only create segment if it's at least 10 seconds long
            if (segmentDuration >= 10) {
              peaks.segments.add({
                startTime: segmentStart,
                endTime: segmentEnd,
                labelText: '',
                color: '#007bff',
                editable: true
              });
              segmentsCreated++;
              addDebugLog(`Created segment: ${segmentStart.toFixed(2)}s - ${segmentEnd.toFixed(2)}s (original: ${startTime.toFixed(2)}s - ${silence.start.toFixed(2)}s)`);
            }
          }
          startTime = silence.end;
        }

        // Create final segment after last silence
        if (duration - startTime >= 0.5) {
          const segmentStart = Math.max(0, startTime - bufferTime);
          const segmentEnd = Math.min(duration, duration); // No buffer needed at the end
          const segmentDuration = segmentEnd - segmentStart;

          // Only create segment if it's at least 10 seconds long
          if (segmentDuration >= 10) {
            peaks.segments.add({
              startTime: segmentStart,
              endTime: segmentEnd,
              labelText: '',
              color: '#007bff',
              editable: true
            });
            segmentsCreated++;
            addDebugLog(`Created final segment: ${segmentStart.toFixed(2)}s - ${segmentEnd.toFixed(2)}s (original: ${startTime.toFixed(2)}s - ${duration.toFixed(2)}s)`);
          }
        }

        updateSegmentList();
        updateProcessButton();
        audioContext.close();
        addDebugLog(`Auto-detected ${segmentsCreated} segments`);

        if (segmentsCreated === 0) {
          alert('No segments created. Your recording may not have enough silence between songs, or the silence is too short.');
        }

        // Hide spinner and re-enable button
        autoDetectSpinner.style.display = 'none';
        autoDetectBtn.disabled = false;
      }

      // Make autoDetectSilence globally accessible
      window.autoDetectSilence = autoDetectSilence;

      // Add unlisted song
      let selectedSongChoice = null; // 'new' or song ID
      let selectedMatchData = null; // Store full match data when selecting existing song

      async function addUnlistedSong() {
        const titleInput = document.getElementById('unlistedSongTitle');
        const songTitle = titleInput.value.trim();

        if (!songTitle) {
          alert('Please enter a song title');
          return;
        }

        if (!selectedSegment) {
          alert('Please select a segment on the waveform first');
          return;
        }

        // Open modal and search for matches
        openAddSongModal(songTitle);
      }

      async function openAddSongModal(title) {
        const modal = new bootstrap.Modal(document.getElementById('addSongModal'));
        
        // Reset state
        selectedSongChoice = null;
        selectedMatchData = null;
        document.getElementById('songMatchLoading').style.display = 'block';
        document.getElementById('songMatchContent').style.display = 'none';
        document.getElementById('confirmAddSongBtn').disabled = true;
        
        // Clear inputs
        document.getElementById('newSongTitle').value = title;
        document.getElementById('newSongArtist').value = '';
        
        modal.show();
        
        try {
          // Fetch matches
          const response = await fetch(`/bands/<%= setlist.band.id %>/songs/find-matches?title=${encodeURIComponent(title)}`);
          
          if (!response.ok) {
            throw new Error('Failed to fetch matches');
          }
          
          const data = await response.json();
          
          // Hide loading, show content
          document.getElementById('songMatchLoading').style.display = 'none';
          document.getElementById('songMatchContent').style.display = 'block';
          
          // Show/hide private checkbox
          const privateContainer = document.getElementById('privateCheckContainer');
          if (data.canMakePrivate) {
            privateContainer.style.display = 'block';
          } else {
            privateContainer.style.display = 'none';
          }
          
          // Populate existing matches
          const existingContainer = document.getElementById('existingMatchesContainer');
          const existingList = document.getElementById('existingMatchesList');
          
          if (data.matches && data.matches.length > 0) {
            existingContainer.style.display = 'block';
            existingList.innerHTML = '';
            
            data.matches.forEach((match, index) => {
              const col = document.createElement('div');
              col.className = 'col-md-6';
              col.innerHTML = `
                <div class="card match-card" style="cursor: pointer;" data-song-id="${match.id}" data-match-index="${index}">
                  <div class="card-body">
                    <div class="song-title"><strong>${match.title}</strong></div>
                    ${match.artists && match.artists.length > 0 
                      ? `<div class="text-muted">by ${match.artists[0].artist.name}</div>` 
                      : ''}
                    ${match.vocalist 
                      ? `<div class="text-muted small">vocals: ${match.vocalist.name}</div>` 
                      : ''}
                    <div class="mt-2">
                      ${match.matchType === 'exact' 
                        ? '<span class="badge bg-success">Exact Match</span>' 
                        : `<span class="badge bg-info">Similar (~${Math.round(match.confidence * 100)}%)</span>`}
                    </div>
                  </div>
                </div>
              `;
              existingList.appendChild(col);
            });
            
            // Add click handlers
            document.querySelectorAll('.match-card').forEach(card => {
              card.addEventListener('click', function() {
                document.querySelectorAll('.match-card').forEach(c => c.classList.remove('border-primary', 'bg-light'));
                this.classList.add('border-primary', 'bg-light');
                selectedSongChoice = this.dataset.songId;
                // Store the full match data
                const matchIndex = parseInt(this.dataset.matchIndex);
                selectedMatchData = data.matches[matchIndex];
                document.getElementById('confirmAddSongBtn').disabled = false;
              });
            });
          } else {
            existingContainer.style.display = 'none';
          }
          
          // Default to "new"
          selectedSongChoice = 'new';
          const newCard = document.querySelector('.new-song-card');
          newCard.classList.add('border-primary', 'bg-light');
          document.getElementById('confirmAddSongBtn').disabled = false;
          
          // Add click handler for new song card
          newCard.addEventListener('click', function() {
            selectedSongChoice = 'new';
            document.querySelectorAll('.match-card').forEach(c => c.classList.remove('border-primary', 'bg-light'));
            this.classList.add('border-primary', 'bg-light');
            document.getElementById('confirmAddSongBtn').disabled = false;
          });
          
        } catch (error) {
          console.error('Error fetching matches:', error);
          alert('Failed to search for similar songs');
        }
      }

      async function confirmAddSong() {
        if (!selectedSongChoice || !selectedSegment) {
          return;
        }

        try {
          let result;
          
          if (selectedSongChoice === 'new') {
            // Create new song
            const title = document.getElementById('newSongTitle').value.trim();
            const artist = document.getElementById('newSongArtist').value.trim();
            const isPrivate = document.getElementById('newSongPrivate').checked;
            
            if (!title) {
              alert('Please enter a song title');
              return;
            }
            
            const response = await fetch('/bands/<%= setlist.band.id %>/songs/quick-add', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ title, artist, isPrivate })
            });
            
            if (!response.ok) {
              throw new Error('Failed to add song');
            }
            
            result = await response.json();
          } else {
            // Use existing song
            result = { songId: parseInt(selectedSongChoice), isExisting: true };
            
            // Check if this song is already in realSongs (from the setlist)
            const existingInRealSongs = realSongs.find(s => s.id === result.songId);
            
            // If not in the setlist, we need to add it to realSongs so it can be assigned
            if (!existingInRealSongs && selectedMatchData) {
              const artist = selectedMatchData.artists && selectedMatchData.artists.length > 0
                ? selectedMatchData.artists[0].artist.name
                : 'Unknown';
              
              const newSong = {
                id: result.songId,
                title: selectedMatchData.title,
                artist: artist
              };
              realSongs.push(newSong);

              // Add to UI
              const songIndex = realSongs.length;
              const div = document.createElement("div");
              div.className = "song-item mb-2 p-2 border rounded";
              div.setAttribute("data-song-id", newSong.id);
              div.setAttribute("data-song-index", songIndex);
              div.setAttribute("data-song-title", newSong.title);
              div.style.cssText = "cursor: pointer; transition: background 0.2s;";
              div.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                  <div>
                    <strong>${songIndex}. ${newSong.title}</strong>
                    <div class="small text-muted">${newSong.artist}</div>
                  </div>
                  <span class="badge bg-secondary" id="song-badge-${newSong.id}" style="display: none;">
                    Assigned
                  </span>
                </div>
              `;
              div.onclick = () => {
                if (selectedSegment) {
                  assignSongToSegment(selectedSegment.id, newSong.id);
                }
              };
              songsList.appendChild(div);
            }
          }

          // Only add new songs to realSongs (not existing ones that were just added)
          if (selectedSongChoice === 'new') {
            const existingInRealSongs = realSongs.find(s => s.id === result.songId);
            if (!existingInRealSongs) {
              const newSong = {
                id: result.songId,
                title: document.getElementById('newSongTitle').value.trim(),
                artist: document.getElementById('newSongArtist').value.trim() || 'Unknown'
              };
              realSongs.push(newSong);

              // Add to UI
              const songIndex = realSongs.length;
              const div = document.createElement("div");
              div.className = "song-item mb-2 p-2 border rounded";
              div.setAttribute("data-song-id", newSong.id);
              div.setAttribute("data-song-index", songIndex);
              div.setAttribute("data-song-title", newSong.title);
              div.style.cssText = "cursor: pointer; transition: background 0.2s;";
              div.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                  <div>
                    <strong>${songIndex}. ${newSong.title}</strong>
                    <div class="small text-muted">${newSong.artist}</div>
                  </div>
                  <span class="badge bg-secondary" id="song-badge-${newSong.id}" style="display: none;">
                    Assigned
                  </span>
                </div>
              `;
              div.onclick = () => {
                if (selectedSegment) {
                  assignSongToSegment(selectedSegment.id, newSong.id);
                }
              };
              songsList.appendChild(div);
            }
          }

          // Assign to the selected segment
          assignSongToSegment(selectedSegment.id, result.songId);

          // Close modal
          bootstrap.Modal.getInstance(document.getElementById('addSongModal')).hide();
          
          // Clear input
          document.getElementById('unlistedSongTitle').value = '';

          addDebugLog(` Song added and assigned to segment!`);
        } catch (error) {
          console.error('Error adding song:', error);
          alert('Failed to add song. Please try again.');
        }
      }

      // Make functions globally accessible for onclick handlers
      window.deleteSegment = deleteSegment;
      window.undoLastRegion = undoLastRegion;
      window.addUnlistedSong = addUnlistedSong;

      function assignSongToSegment(segmentId, songId) {
        const segment = peaks.segments.getSegment(segmentId);
        const song = realSongs.find((s) => String(s.id) === String(songId));

        if (!segment || !song) {
          addDebugLog(`Assign failed: segment or song not found.`);
          return;
        }

        // Store the new assignment
        segmentSongMap[segmentId] = {
          songId: song.id,
          songTitle: song.title,
          start: segment.startTime,
          end: segment.endTime,
        };

        // Update the segment on the waveform
        segment.update({
          labelText: song.title,
          color: "#28a745", // Green for assigned
        });

        // Hide the song from the "Available Songs" list after assignment
        const songItem = document.querySelector(`[data-song-id="${song.id}"]`);
        if (songItem) {
          songItem.style.display = 'none';
        }

        // Deselect segment after successful assignment for a smoother workflow
        selectedSegment = null;

        // Update all UI elements
        updateSegmentList();
        updateSelectedSegmentInfo();
        updateProcessButton();

        addDebugLog(`Assigned ${song.title} to segment ${segment.id}`);
      }

      // Update process button state
      function updateProcessButton() {
        const btn = document.getElementById("processSplitsBtn");
        const statusText = document.getElementById("processSplitsStatus");
        const assignedCount = Object.keys(segmentSongMap).length;
      const undoBtn = document.getElementById('undoBtn');

      if (peaks && peaks.segments.getSegments().length > 0) {
        undoBtn.disabled = false;
      } else {
        undoBtn.disabled = true;
      }

        if (assignedCount > 0) {
          btn.disabled = false;
          if (statusText) {
            statusText.textContent = `${assignedCount} song(s) ready to process`;
          }
        } else {
          btn.disabled = true;
          if (statusText) {
            statusText.textContent =
              "Assign songs to segments to enable processing";
          }
        }
      }

      // Process splits button handler
      document
        .getElementById("processSplitsBtn")
        .addEventListener("click", async function () {
          if (Object.keys(segmentSongMap).length === 0) {
            alert("Please assign songs to segments first");
            return;
          }

          const splits = Object.values(segmentSongMap).map((assignment) => ({
            songId: assignment.songId,
            songTitle: assignment.songTitle,
            start: Math.floor(assignment.start),
            end: Math.floor(assignment.end),
            duration: Math.floor(assignment.end - assignment.start),
          }));

          // Show loading
          this.disabled = true;
          this.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';

          try {
            const response = await fetch(
              "/setlists/<%= setlist.id %>/recordings/<%= recording.id %>/process",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ splits }),
              }
            );

            if (response.ok) {
              const result = await response.json();
              alert(`Successfully split ${splits.length} songs!`);
              window.location.href =
              "/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>/recordings/<%= recording.id %>";
            } else {
            const errorText = await response.text();
            let errorMessage = "Failed to process splits";
            try {
              const errorData = JSON.parse(errorText);
              errorMessage = errorData.error || errorMessage;
            } catch (e) {
              errorMessage = errorText || errorMessage;
            }
            alert(errorMessage);
            throw new Error(errorMessage);
            }
          } catch (error) {
            console.error("Processing error:", error);
            alert("Failed to process splits. Please try again.");
            this.disabled = false;
            this.innerHTML = '<i class="bi bi-scissors"></i> Process Splits';
          }
        });

      function formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return "0:00";
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, "0")}`;
      }

      function showError(message) {
        const alertDiv = document.createElement("div");
        alertDiv.className = "alert alert-danger alert-dismissible fade show";
        alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
        document.body.insertBefore(alertDiv, document.body.firstChild);
    }

    document.addEventListener('keydown', (e) => {
      // Ignore keyboard shortcuts if user is typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      if (e.key === 'Escape') {
        undoLastRegion();
      } else if (e.key === ' ') {
        e.preventDefault();
        document.getElementById('playPauseBtn').click();
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        // Delete the selected segment
        if (selectedSegment) {
          deleteSegment(selectedSegment.id);
        }
      }
    });

    // Allow Enter key in unlisted song input
    const unlistedInput = document.getElementById('unlistedSongTitle');
    if (unlistedInput) {
      unlistedInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addUnlistedSong();
        }
      });
    }

    // Wire up modal buttons
    document.getElementById('addSongBtn').addEventListener('click', addUnlistedSong);
    document.getElementById('confirmAddSongBtn').addEventListener('click', confirmAddSong);
    
    // Make confirmAddSong accessible
    window.confirmAddSong = confirmAddSong;
    });
</script>
