<div class="container mt-4" data-total-songs="<%= totalSongs %>">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
          <h1>Split Recording (Peaks.js)</h1>
          <h2 class="h5 text-muted"><%= setlist.title %></h2>
        </div>
        <a
          href="/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>"
          class="btn btn-outline-secondary"
        >
          <i class="bi bi-arrow-left"></i> Back to Setlist
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- Main Waveform Editor -->
    <div class="col-lg-9">
      <div class="card">
        <div
          class="card-header d-flex justify-content-between align-items-center"
        >
          <h5 class="mb-0">
            <i class="bi bi-scissors"></i> Mark Song Boundaries
          </h5>
          <div class="d-flex gap-2">
            <div class="btn-group" role="group">
              <a
                href="/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>/recordings/<%= recording.id %>/split"
                class="btn btn-sm btn-outline-primary"
              >
                <i class="bi bi-graph-up"></i> WaveSurfer
              </a>
              <button class="btn btn-sm btn-primary" disabled>
                <i class="bi bi-graph-up-arrow"></i> Peaks.js
              </button>
            </div>
            <a
              href="/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>/recordings"
              class="btn btn-sm btn-outline-secondary"
            >
              <i class="bi bi-arrow-left"></i> Back to Recordings
            </a>
          </div>
        </div>
        <div class="card-body">
          <!-- Add custom styles for segment labels -->
          <style>
            .peaks-segment-label {
              position: absolute;
              top: 5px;
              left: 5px;
              color: white;
              background-color: rgba(
                0,
                0,
                0,
                0.6
              ); /* Slightly darker for better contrast */
              padding: 3px 6px;
              border-radius: 3px;
              font-size: 12px;
              font-weight: 600; /* Bolder text */
              pointer-events: none; /* Allows clicks to pass through to the segment */
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              max-width: calc(
                100% - 10px
              ); /* Prevent label from overflowing the segment */
              opacity: 1 !important; /* Force the label to be visible */
              transition: none !important; /* Disable any fade transitions */
            }
          </style>

          <!-- Loading Progress -->
          <div id="loadingProgress" class="text-center mb-3">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">
              <small class="text-muted">Loading audio file...</small>
            </div>
            <div class="progress mt-2" style="height: 6px">
              <div
                id="loadingBar"
                class="progress-bar progress-bar-striped progress-bar-animated"
                role="progressbar"
                style="width: 0%"
              ></div>
            </div>
            <div id="loadingStatus" class="mt-1">
              <small class="text-muted">Preparing waveform...</small>
            </div>
            <div id="loadingNote" class="mt-2" style="display: none">
              <small class="text-info">
                <i class="bi bi-info-circle"></i>
                Large files may take 30+ seconds to process. Please be patient.
              </small>
            </div>
          </div>

          <!-- Peaks.js Waveform Containers -->
          <div
            id="overview-container"
            style="
              height: 100px;
              border: 1px solid #dee2e6;
              border-radius: 4px;
              background: #f8f9fa;
              display: none;
            "
          ></div>
          <div
            id="zoomview-container"
            style="
              height: 200px;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              background: #f8f9fa;
              display: none;
              overflow-y: hidden;
            "
          ></div>

          <!-- Playback Controls -->
          <div
            class="mt-3 d-flex justify-content-center gap-2 align-items-center"
          >
            <button
              id="playPauseBtn"
              class="btn btn-primary"
              style="width: 100px"
            >
              <i class="bi bi-play-fill"></i> Play
            </button>
            <button id="stopBtn" class="btn btn-secondary">
              <i class="bi bi-stop-fill"></i> Restart
            </button>
            <div class="mx-3" style="width: 180px; text-align: center">
              <span id="currentTime">0:00</span> /
              <span id="totalTime">0:00</span>
            </div>
            <div class="d-flex align-items-center gap-2">
              <label for="zoom" class="mb-0">Zoom:</label>
              <input
                type="range"
                id="zoom"
                min="0"
                max="100"
                value="0"
                step="1"
                class="form-range"
                style="width: 150px"
              />
              <button
                id="resetZoomBtn"
                class="btn btn-sm btn-outline-secondary"
              >
                <i class="bi bi-arrow-clockwise"></i> Reset
              </button>
            </div>
          </div>

          <!-- Instructions -->
          <style>
            kbd {
              background-color: #0d6efd;
              color: white;
              padding: 2px 6px;
              border-radius: 4px;
              border: 1px solid #0a58ca;
            }
          </style>
          <div class="mt-3 alert alert-info">
            <strong
              ><i class="bi bi-info-circle"></i> Key Commands &
              Workflow:</strong
            >
            <ul class="mb-0 mt-2">
              <li>
                <strong>Create Segment:</strong> Click and drag on the main
                waveform. The new segment will be highlighted yellow, making it
                the active selection.
              </li>
              <li>
                <strong>Assign Song:</strong> With a segment selected (yellow),
                click a song from the "Available Songs" list on the right.
              </li>
              <li>
                <strong>To Zoom:</strong> Use the zoom slider to get a more
                detailed view.
              </li>
              <li>
                <strong>To Pan/Scroll View:</strong> Hold <kbd>Option</kbd> (or
                <kbd>Alt</kbd>) while clicking and dragging the main waveform to
                move it left and right.
              </li>
              <li>
                <strong>Seek Playhead:</strong> Click anywhere on the waveform
                to move the playhead to that spot.
              </li>
              <li>
                <strong>Undo:</strong> Press <kbd>ESC</kbd> or click the "Undo"
                button to remove the last created segment.
              </li>
              <li>
                <strong>Process:</strong> When all songs are assigned, click
                "Process Splits".
              </li>
            </ul>
          </div>

          <!-- Utility Buttons -->
          <div class="mt-3 d-flex gap-2 justify-content-center flex-wrap">
            <button
              id="undoBtn"
              onclick="undoLastRegion()"
              class="btn btn-outline-warning"
              disabled
            >
              <i class="bi bi-arrow-counterclockwise"></i> Undo Last Segment
              <kbd>ESC</kbd>
            </button>
            <button id="autoDetectBtn" class="btn btn-outline-info" disabled>
              <i class="bi bi-magic"></i> Auto-Detect Silence
            </button>
            <button id="processSplitsBtn" class="btn btn-success" disabled>
              <i class="bi bi-scissors"></i> Process Splits
            </button>
          </div>
          <div id="processSplitsStatus" class="text-center mt-2">
            <small class="text-muted"
              >Assign songs to segments to enable processing</small
            >
          </div>
        </div>
      </div>
    </div>

    <!-- Song Assignment Panel -->
    <div class="col-lg-3">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0"><i class="bi bi-list-music"></i> Song Assignment</h5>
        </div>
        <div class="card-body">
          <div id="segmentsList" class="mb-3">
            <p class="text-muted">
              No segments created yet. Drag on the waveform to create segments.
            </p>
          </div>

          <div class="mb-3">
            <h6>Available Songs:</h6>
            <div id="songsList" class="list-group">
              <!-- Songs will be populated here -->
            </div>
          </div>

          <div class="mb-3">
            <h6>Selected Segment:</h6>
            <div id="selectedSegmentInfo" class="alert alert-light">
              <p class="mb-0 text-muted">No segment selected</p>
            </div>
          </div>

          <div class="mt-4">
            <!-- This button is now in the main panel -->
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Hidden Audio Element -->
<audio id="audio" preload="metadata" style="display: none">
  <!-- Audio source will be set dynamically -->
</audio>

<!-- Peaks.js Dependencies -->
<script src="/js/konva.min.js"></script>
<script src="/js/waveform-data.min.js"></script>
<script src="/js/peaks.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    console.log("=== PEAKS.JS SPLIT PAGE STARTING ===");

    // Add visual debugging instead of console logs
    const debugDiv = document.createElement("div");
    debugDiv.style.cssText =
      "position: fixed; top: 10px; right: 10px; background: #000; color: #fff; padding: 10px; z-index: 9999; font-family: monospace; font-size: 12px; max-width: 300px; max-height: 200px; overflow-y: auto; border: 1px solid #333;";
    debugDiv.innerHTML = "<div>JavaScript loaded</div>";
    document.body.appendChild(debugDiv);

    function addDebugLog(message) {
      const logDiv = document.createElement("div");
      logDiv.textContent = new Date().toLocaleTimeString() + ": " + message;
      debugDiv.appendChild(logDiv);
      console.log(message); // Still try console
    }

    // Check if libraries are loaded
    addDebugLog("Checking libraries...");
    addDebugLog("Peaks available: " + typeof Peaks);
    addDebugLog("window.peaks available: " + typeof window.peaks);

    let peaks = null;
    let selectedSegment = null;
    const segmentSongMap = {};

    // Real songs from your setlist
    const realSongs = <%- JSON.stringify(
      setlist.sets
        .filter(set => set.name !== 'Maybe')
        .flatMap(set =>
          (set.songs || []).map(setlistSong => ({
            id: setlistSong.song.id,
            title: setlistSong.song.title,
            artist: (setlistSong.song.artists && setlistSong.song.artists.length > 0)
              ? setlistSong.song.artists[0].artist.name
              : 'Unknown'
          }))
        )
    ) %>;

    // Load the actual recording file
    const audioElement = document.getElementById("audio");
    const recordingPath = window.location.origin + "<%= recording.filePath %>";

    addDebugLog("Loading recording: " + recordingPath);
    addDebugLog("Audio element found: " + (audioElement ? "Yes" : "No"));
    audioElement.src = recordingPath;

    // Add audio event listeners for debugging
    audioElement.addEventListener("canplay", () => {
      addDebugLog("Audio can play - duration: " + audioElement.duration);
    });
    audioElement.addEventListener("error", (e) => {
      addDebugLog("Audio error: " + e.message);
    });

    // Populate songs list
    const songsList = document.getElementById("songsList");
    let songIndex = 1;
    realSongs.forEach((song) => {
      const div = document.createElement("div");
      div.className = "song-item mb-2 p-2 border rounded";
      div.setAttribute("data-song-id", song.id);
      div.setAttribute("data-song-index", songIndex);
      div.setAttribute("data-song-title", song.title);
      div.style.cssText = "cursor: pointer; transition: background 0.2s;";
      div.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <strong>${songIndex}. ${song.title}</strong>
            <div class="small text-muted">${song.artist}</div>
          </div>
          <span class="badge bg-secondary" id="song-badge-${song.id}" style="display: none;">
            Assigned
          </span>
        </div>
      `;
      div.onclick = () => {
        addDebugLog(`Song clicked: ${song.title}. Current selectedSegment ID: ${selectedSegment ? selectedSegment.id : 'null'}`);
        if (selectedSegment) {
          assignSongToSegment(selectedSegment.id, song.id);
        } else {
          addDebugLog(
            "Please select a segment first by clicking on it in the waveform."
          );
        }
      };
      songsList.appendChild(div);
      songIndex++;
    });

    // Initialize Peaks.js - fix race condition
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", function () {
        initPeaks();
      });
    } else {
      // DOM is already ready
      initPeaks();
    }

    function initPeaks() {
      const overviewContainer = document.getElementById("overview-container");
      const zoomviewContainer = document.getElementById("zoomview-container");

      console.log("Initializing Peaks.js...");
      console.log("Overview container:", overviewContainer);
      console.log("Zoomview container:", zoomviewContainer);
      console.log("Audio element:", audioElement);
      console.log("Peaks available:", typeof Peaks);

      addDebugLog("Initializing Peaks.js...");

      // Check if audio is already ready, or wait for it
      if (audioElement.readyState >= 3) {
        // HAVE_FUTURE_DATA or higher
        addDebugLog("Audio already ready, initializing Peaks immediately");
        initializePeaksWithAudio();
      } else {
        addDebugLog("Audio not ready, waiting for canplay event");
        audioElement.addEventListener("canplay", () => {
          addDebugLog(
            "Audio can play event fired - readyState: " +
              audioElement.readyState
          );
          addDebugLog("Audio duration: " + audioElement.duration);
          initializePeaksWithAudio();
        });
      }
    }

    let peaksInitialized = false;

    function initializePeaksWithAudio() {
      if (peaksInitialized) {
        addDebugLog("Peaks.js already initialized - skipping re-initialization");
        return;
      }
      addDebugLog("Starting Peaks.js initialization...");

      const overviewContainer = document.getElementById("overview-container");
      const zoomviewContainer = document.getElementById("zoomview-container");

      //   const options = {
      //     containers: {
      //       overview: overviewContainer,
      //       zoomview: zoomviewContainer,
      //     },
      //     mediaElement: audioElement,
      //     webAudio: {
      //       audioContext: new (window.AudioContext ||
      //         window.webkitAudioContext)(),
      //     },
      //     segments: [],
      //   };o

      addDebugLog("Calling Peaks.init()...");
      //   const PeaksLib = window.peaks || window.Peaks;
      //   addDebugLog("Using PeaksLib: " + typeof PeaksLib);

      // Debug container elements
      addDebugLog(
        "Overview container type: " + overviewContainer.constructor.name
      );
      addDebugLog("Overview container tagName: " + overviewContainer.tagName);
      addDebugLog(
        "Zoomview container type: " + zoomviewContainer.constructor.name
      );
      addDebugLog("Zoomview container tagName: " + zoomviewContainer.tagName);
      addDebugLog("Audio element type: " + audioElement.constructor.name);

      // Show the actual HTML content of containers
      addDebugLog(
        "Overview container HTML: " +
          overviewContainer.outerHTML.substring(0, 100) +
          "..."
      );
      addDebugLog(
        "Zoomview container HTML: " +
          zoomviewContainer.outerHTML.substring(0, 100) +
          "..."
      );
      addDebugLog(
        "Audio element HTML: " +
          audioElement.outerHTML.substring(0, 100) +
          "..."
      );

      // Show container dimensions and visibility
      addDebugLog(
        "Overview dimensions: " +
          overviewContainer.offsetWidth +
          "x" +
          overviewContainer.offsetHeight
      );
      addDebugLog(
        "Zoomview dimensions: " +
          zoomviewContainer.offsetWidth +
          "x" +
          zoomviewContainer.offsetHeight
      );
      addDebugLog(
        "Overview visible: " +
          (overviewContainer.offsetWidth > 0 &&
            overviewContainer.offsetHeight > 0)
      );
      addDebugLog(
        "Zoomview visible: " +
          (zoomviewContainer.offsetWidth > 0 &&
            zoomviewContainer.offsetHeight > 0)
      );

      // Fix container dimensions - ensure they have width and are visible
      addDebugLog("Fixing container dimensions...");
      overviewContainer.style.width = "100%";
      overviewContainer.style.minHeight = "100px";
      overviewContainer.style.display = "block";
      zoomviewContainer.style.width = "100%";
      zoomviewContainer.style.minHeight = "200px";
      zoomviewContainer.style.display = "block";

      // Check dimensions again after fixing
      addDebugLog(
        "After fix - Overview dimensions: " +
          overviewContainer.offsetWidth +
          "x" +
          overviewContainer.offsetHeight
      );
      addDebugLog(
        "After fix - Zoomview dimensions: " +
          zoomviewContainer.offsetWidth +
          "x" +
          zoomviewContainer.offsetHeight
      );

      // Call Peaks.js immediately - no setTimeout delay
      addDebugLog("Attempting Peaks.js initialization...");

      // Use the working approach from prototype2
      const PeaksLib = window.peaks || window.Peaks;
      addDebugLog("Using PeaksLib: " + typeof PeaksLib);

      const options = {
        overview: {
          container: overviewContainer,
        },
        zoomview: {
          container: zoomviewContainer,
          // Disable default click-to-seek behavior that resets zoom
          axisGridlineColor: "#ccc",
          axisLabelColor: "#000",
          // Try to prevent auto-scrolling during segment drag
          playheadColor: "#f00",
          playheadTextColor: "#000",
          // Enable scrollbar when zoomed in
          enableScrollbar: true,
          showSegmentLabels: true,
          // CRITICAL: Disable Peaks.js's built-in mouse interactions
          enableMarkerEditing: false,
          enableSegmentDragging: false
        },
        mediaElement: audioElement,
        // Use pre-computed waveform data if available
        <% if (recording.waveformPath) { %>
        dataUri: {
          arraybuffer: "<%= recording.waveformPath %>"
        },
        <% } else { %>
        // Fallback to generating waveform in the browser
        webAudio: {
          audioContext: new (window.AudioContext || window.webkitAudioContext)(),
          scale: 512,
          multiChannel: false
        },
        <% } %>
        segments: [],
        // Disable default keyboard shortcuts that might interfere
        keyboard: false,
        // Disable default point editing
        pointMarkerColor: "#ff0000",
        // Disable segment dragging to prevent interference with our custom segment creation
        segmentOptions: {
          markers: false
        },
        // Explicitly disable Peaks.js's built-in click-to-seek and drag-to-scroll
        zoomLevels: [512, 1024, 2048, 4096]
      };

      PeaksLib.init(options, (err, p) => {
        if (err) {
          console.error("Failed to initialize Peaks.js:", err);
          addDebugLog("Peaks.js init error: " + err.message);
          addDebugLog("Full error: " + JSON.stringify(err));
          addDebugLog("Error stack: " + err.stack);
          addDebugLog("Options used: " + JSON.stringify(options));
          showError("Failed to initialize waveform editor: " + err.message);
          return;
        }

        peaks = p;
        console.log("Peaks.js initialized successfully");
        addDebugLog("Peaks.js initialized successfully!");
        peaksInitialized = true; // Mark as initialized to prevent re-initialization
        addDebugLog("Peaks instance: " + typeof peaks);
        addDebugLog("Peaks player: " + typeof peaks.player);
        addDebugLog("Peaks zoom: " + typeof peaks.zoom);

        // Debug audio duration
        addDebugLog("Audio element duration: " + audioElement.duration);
        addDebugLog("Peaks player duration: " + peaks.player.getDuration());
        <% if (recording.waveformPath) { %>
        addDebugLog(
          "Using pre-computed waveform data: <%= recording.waveformPath %>"
        );
        <% } else { %>
        addDebugLog(
          "No pre-computed waveform data found. Using Web Audio API."
        );
        <% } %>

        // Hide loading progress

        // Hide loading progress and show waveform
        document.getElementById("loadingProgress").style.display = "none";
        overviewContainer.style.display = "block";
        zoomviewContainer.style.display = "block";
        addDebugLog("Waveform containers shown");

        // Set up controls
        setupControls();
        setupSegmentEvents();

        // Initialize process button state
        updateProcessButton();

        // Set initial zoom to show whole file
        const zoomview = peaks.views.getView("zoomview");
        const scrollbar = peaks.views.getScrollbar();
        zoomview.setZoom({ seconds: "auto" });
        document.getElementById("zoom").value = 0; // Slider at left = auto
        // Hide scrollbar initially (zoomed out)
        if (scrollbar) {
          scrollbar.hide();
        }

        // Update total time
        document.getElementById("totalTime").textContent = formatTime(
          Math.floor(audioElement.duration)
        );

        // CRITICAL: Disable Peaks.js's built-in drag-to-scroll by making ALL canvases non-interactive
        // We'll handle segment editing through Peaks.js API instead
        setTimeout(() => {
          const allCanvases = zoomviewContainer.querySelectorAll('canvas');
          addDebugLog("Found " + allCanvases.length + " canvas elements in zoomview");
          allCanvases.forEach((canvas, index) => {
            canvas.style.pointerEvents = 'none';
            addDebugLog("Disabled pointer events on canvas " + index);
          });
          const konvaContainer = zoomviewContainer.querySelector('.konvajs-content');
          if (konvaContainer) {
            konvaContainer.style.pointerEvents = 'none';
            addDebugLog("Disabled pointer events on konva container");
          }
        }, 100);

        addDebugLog("Setup complete!");
      });
    }

    // Handle audio errors
    audioElement.addEventListener("error", (e) => {
      console.error("Audio loading error:", e);
      addDebugLog("Audio error: " + e.message);
      showError("Failed to load audio file: " + recordingPath);
    });

    // Setup UI controls
    let controlsSetup = false;
    function setupControls() {
      if (controlsSetup) {
        addDebugLog("Controls already setup - skipping");
        return;
      }
      controlsSetup = true;

      // Play/Pause button
      const playBtn = document.getElementById("playPauseBtn");
      if (playBtn) {
        let isProcessing = false; // Prevent rapid clicks
        playBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (isProcessing) {
            addDebugLog("Click ignored - already processing");
            return;
          }

          isProcessing = true;
          addDebugLog("Button clicked - paused: " + audioElement.paused);

          try {
            if (audioElement.paused) {
              addDebugLog("Calling audioElement.play()");
              await audioElement.play();
              playBtn.innerHTML = '<i class="bi bi-pause-fill"></i> Pause';
              addDebugLog("Play successful");
            } else {
              addDebugLog("Calling audioElement.pause()");
              audioElement.pause();
              playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
              addDebugLog("Pause successful");
            }
          } catch (error) {
            addDebugLog("Play error: " + error.message);
            playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
          } finally {
            // Reset processing flag after a short delay
            setTimeout(() => {
              isProcessing = false;
            }, 100);
          }
        });
      }

      // Stop button
      const stopBtn = document.getElementById("stopBtn");
      if (stopBtn) {
        stopBtn.addEventListener("click", () => {
          audioElement.pause();
          audioElement.currentTime = 0;
          playBtn.innerHTML = '<i class="bi bi-play-fill"></i> Play';
        });
      }

    // Zoom control
    const zoomSlider = document.getElementById("zoom");
    if (zoomSlider) {
      zoomSlider.addEventListener("input", (e) => {
        const sliderValue = Number(e.target.value);
        const zoomview = peaks.views.getView("zoomview");
        const scrollbar = peaks.views.getScrollbar();

        if (sliderValue === 0) {
          // Slider at left = auto (show whole file)
          zoomview.setZoom({ seconds: "auto" });
          // Hide scrollbar when zoomed out
          scrollbar?.hide();
        } else {
          // Slider at right = show fewer seconds (more zoomed in)
          const totalDuration = audioElement.duration;
          const secondsToShow =
            totalDuration - (sliderValue / 100) * (totalDuration - 1);
          zoomview.setZoom({ seconds: secondsToShow });
          // Show scrollbar when zoomed in
          scrollbar?.show();
        }
      });
    }

    // Reset zoom
    document.getElementById("resetZoomBtn").addEventListener("click", () => {
      const zoomview = peaks.views.getView("zoomview");
      const scrollbar = peaks.views.getScrollbar();
      zoomview.setZoom({ seconds: "auto" });
      document.getElementById("zoom").value = 0;
      // Hide scrollbar when resetting to auto zoom
      scrollbar?.hide();
    });
    }

    // Setup Peaks.js segment events
    let segmentEventsSetup = false;
    function setupSegmentEvents() {
      if (segmentEventsSetup) {
        addDebugLog("Segment events already setup - skipping");
        return;
      }
      segmentEventsSetup = true;

      // Enable segment creation by dragging
      peaks.on("segments.add", (segment) => {
        // This event is for segments created via the UI, which we have customized.
        // The main logic is now handled manually after creation.
        addDebugLog("peaks.on segments.add fired.");
      });

      // Update time display using native audio element
      audioElement.addEventListener("timeupdate", () => {
        document.getElementById("currentTime").textContent = formatTime(audioElement.currentTime);
      });

      // Don't add play/pause event listeners - button handler updates manually
      // This prevents duplicate event handling

      // Monitor zoom changes and prevent unwanted resets
      let zoomCheckInterval = null;
      const startZoomMonitoring = () => {
        if (zoomCheckInterval) return;
        zoomCheckInterval = setInterval(() => {
          try {
            const zoomview = peaks.views.getView("zoomview");
            const startTime = zoomview.getStartTime();
            const endTime = zoomview.getEndTime();
            const visibleDuration = endTime - startTime;

            // If zoom suddenly changes to auto (full duration), restore it
            if (currentZoomSeconds && visibleDuration >= audioElement.duration * 0.99) {
              const sliderValue = document.getElementById("zoom").value;
              if (sliderValue != 0) {
                addDebugLog("Detected zoom reset - restoring");
                restoreZoomIfNeeded();
              }
            }
          } catch (err) {
            // Ignore errors - zoom monitoring may fail if Peaks.js not ready
          }
        }, 100);
      };

      // Start monitoring after initial setup
      setTimeout(() => {
        startZoomMonitoring();
      }, 1000);

      // Prevent zoom reset - store current zoom state
      let currentZoomSeconds = null;

      // Store current zoom before any interaction
      function storeCurrentZoom() {
        try {
          const zoomview = peaks.views.getView("zoomview");
          const startTime = zoomview.getStartTime();
          const endTime = zoomview.getEndTime();
          const visibleDuration = endTime - startTime;
          if (visibleDuration > 0 && visibleDuration < audioElement.duration) {
            currentZoomSeconds = visibleDuration;
            addDebugLog("Stored zoom: " + currentZoomSeconds.toFixed(1) + " seconds");
          } else {
             addDebugLog("Did not store zoom. Visible duration: " + visibleDuration);
          }
        } catch (err) {
          addDebugLog("Error in storeCurrentZoom: " + err.message);
        }
      }

      // Restore zoom if it gets reset
      function restoreZoomIfNeeded() {
        addDebugLog(`restoreZoomIfNeeded called. Stored zoom is: ${currentZoomSeconds ? currentZoomSeconds.toFixed(1) : 'null'}`);
        if (currentZoomSeconds && currentZoomSeconds < audioElement.duration) {
          try {
            const sliderValue = document.getElementById("zoom").value;
            if (sliderValue != 0) {
              // Only restore if zoom slider is not at 0 (auto)
              const zoomview = peaks.views.getView("zoomview");
              zoomview.setZoom({ seconds: currentZoomSeconds });
              addDebugLog("Restored zoom to: " + currentZoomSeconds.toFixed(1) + " seconds");
            }
          } catch (err) {
            // Ignore errors
          }
        }
      }

      // Enable segment creation by dragging and prevent zoom reset
      const zoomviewContainer = document.getElementById("zoomview-container");
      let isDragging = false;
      let dragStart = null;
      let dragStartX = null;
      let isPanning = false;
      let panStartX = null;
      let tempSegment = null;
      let isPreparingToDrag = false;
      let isResizing = false;
      let resizeSegment = null;
      let resizeEdge = null; // 'start' or 'end'

      // Helper function to check if clicking near a segment edge
      function findSegmentEdgeAtTime(time, tolerance = 2) {
        const segments = peaks.segments.getSegments();
        for (const segment of segments) {
          const startDiff = Math.abs(segment.startTime - time);
          const endDiff = Math.abs(segment.endTime - time);

          if (startDiff < tolerance) {
            return { segment, edge: 'start' };
          } else if (endDiff < tolerance) {
            return { segment, edge: 'end' };
          }
        }
        return null;
      }

      // Helper function to find segment at a given time (for selection)
      function findSegmentAtTime(time) {
        const segments = peaks.segments.getSegments();
        for (const segment of segments) {
          if (time >= segment.startTime && time <= segment.endTime) {
            return segment;
          }
        }
        return null;
      }

      // Define drag handlers before they're referenced
      const handleDragMove = (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (isResizing && resizeSegment) {
          // Handle segment resizing
          isDragging = true;
          const rect = zoomviewContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const zoomview = peaks.views.getView("zoomview");

          const startTime = zoomview.getStartTime();
          const endTime = zoomview.getEndTime();
          const visibleDuration = endTime - startTime;
          const width = zoomviewContainer.offsetWidth;
          const currentTime = startTime + (x / width) * visibleDuration;

          // Update the segment's start or end time
          if (resizeEdge === 'start') {
            if (currentTime < resizeSegment.endTime) {
              resizeSegment.update({ startTime: currentTime });
            }
          } else if (resizeEdge === 'end') {
            if (currentTime > resizeSegment.startTime) {
              resizeSegment.update({ endTime: currentTime });
            }
          }

        } else if (dragStart !== null) {
          // Handle new segment creation
          isDragging = true;
          const rect = zoomviewContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const zoomview = peaks.views.getView("zoomview");

          // Manual calculation since pointer events are disabled on canvas
          const startTime = zoomview.getStartTime();
          const endTime = zoomview.getEndTime();
          const visibleDuration = endTime - startTime;
          const width = zoomviewContainer.offsetWidth;
          const currentTime = startTime + (x / width) * visibleDuration;

          const segmentStart = Math.min(dragStart, currentTime);
          const segmentEnd = Math.max(dragStart, currentTime);

          if (isPreparingToDrag) {
            isPreparingToDrag = false;
            // Create the temp segment on the first mouse move
            try {
              const result = peaks.segments.add({
                startTime: segmentStart,
                endTime: segmentEnd,
                id: 'temp-drag-segment',
                color: 'rgba(0, 123, 255, 0.3)',
                editable: false
              });
              addDebugLog("peaks.segments.add returned type: " + typeof result + ", isArray: " + Array.isArray(result) + ", keys: " + (result ? Object.keys(result).join(',') : 'N/A'));

              // Handle both array and single object return types
              if (Array.isArray(result) && result.length > 0) {
                tempSegment = result[0];
                addDebugLog("Created temp drag segment from array, ID: " + tempSegment.id);
              } else if (result && typeof result === 'object' && result.id) {
                tempSegment = result;
                addDebugLog("Created temp drag segment directly, ID: " + tempSegment.id);
              } else {
                addDebugLog("peaks.segments.add returned unexpected format");
              }
            } catch (err) {
              addDebugLog("Error creating temp segment: " + err.message);
            }
          } else if (tempSegment) {
            // Update the existing temp segment
            try {
              tempSegment.update({
                startTime: segmentStart,
                endTime: segmentEnd
              });
            } catch (err) {
              addDebugLog("Error updating temp segment: " + err.message);
            }
          }
        }
      };

      const handleDragEnd = (e) => {
        addDebugLog("handleDragEnd called. isDragging: " + isDragging + ", isResizing: " + isResizing + ", tempSegment: " + (tempSegment ? tempSegment.id : "null") + ", dragStart: " + dragStart);
        window.removeEventListener('mousemove', handleDragMove);
        window.removeEventListener('mouseup', handleDragEnd);

        if (isResizing && resizeSegment) {
          // Resize complete
          addDebugLog(`Finished resizing segment ${resizeSegment.id}`);
          zoomviewContainer.style.cursor = 'default';
          updateSegmentList();
          isResizing = false;
          resizeSegment = null;
          resizeEdge = null;
        } else if (isDragging && tempSegment) {
          // Only create permanent segment if we actually dragged
          const startTime = tempSegment.startTime;
          const endTime = tempSegment.endTime;

          // Remove the temporary segment
          peaks.segments.removeById('temp-drag-segment');

          // Create the final permanent segment
          const finalSegment = peaks.segments.add({
            startTime: startTime,
            endTime: endTime,
            labelText: "",
            color: '#007bff',
            editable: true
          })[0];

          addDebugLog(`Segment created from drag with ID: ${finalSegment.id}`);

          // Auto-select the new segment
          if (selectedSegment) {
            const oldAssignment = segmentSongMap[selectedSegment.id];
            selectedSegment.update({ color: oldAssignment ? '#28a745' : '#007bff' });
          }
          selectedSegment = finalSegment;
          selectedSegment.update({ color: '#ffc107' });
          updateSelectedSegmentInfo();
          updateSegmentList();

          tempSegment = null;

        } else if (dragStart !== null && !isDragging) {
            // This was a click, not a drag. Seek the playhead.
            peaks.player.seek(dragStart);
            addDebugLog("Seeked playhead to: " + dragStart.toFixed(2));
        }

        // Always clean up temp segment if it exists but wasn't converted
        if (tempSegment) {
          try {
            peaks.segments.removeById('temp-drag-segment');
            addDebugLog("Cleaned up leftover temp segment");
          } catch (err) {
            // Ignore if already removed
          }
          tempSegment = null;
        }

        // Restore zoom after interaction
        setTimeout(() => {
          restoreZoomIfNeeded();
        }, 100);

        // Reset all drag-related state
        isDragging = false;
        dragStart = null;
        dragStartX = null;
        isPreparingToDrag = false;
      };

      const handlePanMove = (e) => {
        if (!isPanning) return;
        const dx = e.clientX - panStartX;
        const zoomview = peaks.views.getView("zoomview");
        const duration = zoomview.getEndTime() - zoomview.getStartTime();
        const pixelsPerSecond = zoomviewContainer.offsetWidth / duration;
        const timeOffset = dx / pixelsPerSecond;
        zoomview.setStartTime(zoomview.getStartTime() - timeOffset);
        panStartX = e.clientX;
        e.preventDefault();
      };

      const handlePanEnd = (e) => {
        if (isPanning) {
          isPanning = false;
          zoomviewContainer.style.cursor = "default";
          window.removeEventListener("mousemove", handlePanMove);
          window.removeEventListener("mouseup", handlePanEnd);
          e.preventDefault();
        }
      };

      // Prevent overview clicks from resetting zoom
      const overviewContainer = document.getElementById("overview-container");
      overviewContainer.addEventListener("mousedown", (e) => {
        addDebugLog("Overview mousedown detected. Storing zoom.");
        storeCurrentZoom();
        // Use a timeout to restore the zoom after Peaks.js has finished its default action
        setTimeout(() => {
          addDebugLog("Overview timeout fired. Restoring zoom.");
          restoreZoomIfNeeded();
        }, 50);
      });

      // Use event capturing (true parameter) to intercept BEFORE Peaks.js handlers
      zoomviewContainer.addEventListener("mousedown", (e) => {
        // Check for pan mode (Option/Alt key)
        if (e.altKey) {
          isPanning = true;
          panStartX = e.clientX;
          zoomviewContainer.style.cursor = "grabbing";
          window.addEventListener("mousemove", handlePanMove);
          window.addEventListener("mouseup", handlePanEnd);
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        // CRITICAL: Prevent Peaks.js default click handler and drag-to-scroll
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation(); // Also prevent other handlers on same element

        // Store current zoom before interaction
        storeCurrentZoom();

        // Calculate click position and time
        const rect = zoomviewContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const zoomview = peaks.views.getView("zoomview");

        // Convert pixel position to time
        const startTime = zoomview.getStartTime();
        const endTime = zoomview.getEndTime();
        const visibleDuration = endTime - startTime;
        const width = zoomviewContainer.offsetWidth;
        const time = startTime + (x / width) * visibleDuration;

        addDebugLog(`Visible range: ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s, clicked at x=${x}, calculated time=${time.toFixed(2)}s`);

        // Check if clicking near a segment edge for resizing
        const edgeInfo = findSegmentEdgeAtTime(time);

        if (edgeInfo) {
          // Start resizing
          addDebugLog(`Starting resize of segment ${edgeInfo.segment.id} on ${edgeInfo.edge} edge`);
          isResizing = true;
          resizeSegment = edgeInfo.segment;
          resizeEdge = edgeInfo.edge;
          isDragging = false;
          dragStart = null;
          zoomviewContainer.style.cursor = 'ew-resize';
          window.addEventListener('mousemove', handleDragMove);
          window.addEventListener('mouseup', handleDragEnd);
        } else {
          // Check if clicking inside a segment (for selection)
          const clickedSegment = findSegmentAtTime(time);

          if (clickedSegment) {
            // Select the segment
            addDebugLog(`Selecting segment ${clickedSegment.id}`);

            // Deselect previous segment
            if (selectedSegment) {
              const oldAssignment = segmentSongMap[selectedSegment.id];
              selectedSegment.update({ color: oldAssignment ? '#28a745' : '#007bff' });
            }

            // Select new segment
            selectedSegment = clickedSegment;
            selectedSegment.update({ color: '#ffc107' }); // Highlight yellow
            updateSelectedSegmentInfo();
            updateSegmentList();
          } else {
            // Start segment creation (clicked on empty waveform)
            addDebugLog("mousedown at x=" + x + ", time=" + time.toFixed(2));
            isPreparingToDrag = true;
            isDragging = false;
            dragStart = time;
            dragStartX = x;
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('mouseup', handleDragEnd);
          }
        }
      });
    }

    // Update the list of segments in the UI
    function updateSegmentList() {
      const segmentsList = document.getElementById("segmentsList");
      const segments = peaks.segments.getSegments();

      if (segments.length === 0) {
        segmentsList.innerHTML =
          '<p class="text-muted">No segments created yet. Drag on the waveform to create segments.</p>';
        return;
      }

      let html = '<div class="list-group">';
      segments.forEach((segment, index) => {
        const assignment = segmentSongMap[segment.id];
        const songTitle = assignment
          ? assignment.songTitle
          : "No song assigned";

        html += `
                  <div class="list-group-item d-flex justify-content-between align-items-center ${selectedSegment && selectedSegment.id === segment.id ? 'active' : ''}">
                      <div>
                          <strong>Segment ${index + 1}</strong><br>
                          <small class="text-muted">${formatTime(segment.startTime)} - ${formatTime(segment.endTime)}</small><br>
                          <small class="text-info">${songTitle}</small>
                      </div>
                      <button class="btn btn-sm btn-outline-danger" onclick="deleteSegment('${segment.id}')">
                          <i class="bi bi-trash"></i>
                      </button>
                  </div>
              `;
      });
      html += "</div>";

      segmentsList.innerHTML = html;
    }

    // Update info panel for the selected segment
    function updateSelectedSegmentInfo() {
      const infoDiv = document.getElementById("selectedSegmentInfo");

      if (!selectedSegment) {
        infoDiv.innerHTML = '<p class="mb-0 text-muted">No segment selected</p>';
        return;
      }

      const assignment = segmentSongMap[selectedSegment.id];
      const songTitle = assignment ? `Assigned: ${assignment.songTitle}` : "No song assigned";

      infoDiv.innerHTML = `
        <div class="mb-2">
            <strong>Segment Details:</strong><br>
            <small class="text-muted">${formatTime(selectedSegment.startTime)} - ${formatTime(selectedSegment.endTime)}</small><br>
            <small class="text-info">${songTitle}</small>
        </div>
      `;
    }

    // Helper functions
      function deleteSegment(segmentId) {
        const segment = peaks.segments.getSegment(segmentId);
        if (!segment) return;

        // If the segment had a song, make that song available again in the UI
        const assignment = segmentSongMap[segmentId];
        if (assignment) {
          const songItem = document.querySelector(`[data-song-id="${assignment.songId}"]`);
          if (songItem) {
            songItem.style.display = 'block';
          }
        }

        peaks.segments.removeById(segmentId);
        delete segmentSongMap[segmentId];

        if (selectedSegment && selectedSegment.id === segmentId) {
          selectedSegment = null;
        }

        updateSegmentList();
        updateSelectedSegmentInfo();
        updateProcessButton();
      }

      function assignSongToSegment(segmentId, songId) {
        const segment = peaks.segments.getSegment(segmentId);
        const song = realSongs.find((s) => String(s.id) === String(songId));

        if (!segment || !song) {
          addDebugLog(`Assign failed: segment or song not found.`);
          return;
        }

        // If this song is already assigned to a different segment, unassign it from the old one.
        for (const [key, value] of Object.entries(segmentSongMap)) {
          if (String(value.songId) === String(songId) && key !== segmentId) {
            const oldSegment = peaks.segments.getSegment(key);
            if (oldSegment) {
              oldSegment.update({ labelText: '', color: '#007bff' });
            }
            delete segmentSongMap[key];

            // Make the song visible again in the list before re-assigning
            const oldSongItem = document.querySelector(`[data-song-id="${songId}"]`);
            if (oldSongItem) {
              oldSongItem.style.display = 'block';
            }
          }
        }

        // Store the new assignment
        segmentSongMap[segmentId] = {
          songId: song.id,
          songTitle: song.title,
          start: segment.startTime,
          end: segment.endTime,
        };

        // Update the segment on the waveform
        segment.update({
          labelText: song.title,
          color: "#28a745", // Green for assigned
        });

        // Visually hide the song from the "Available" list
        const songItem = document.querySelector(`[data-song-id="${song.id}"]`);
        if (songItem) {
          songItem.style.display = 'none';
        }

        // Deselect segment after successful assignment for a smoother workflow
        selectedSegment = null;

        // Update all UI elements
        updateSegmentList();
        updateSelectedSegmentInfo();
        updateProcessButton();

        addDebugLog(`Assigned ${song.title} to segment ${segment.id}`);
      }

    // Update process button state
    function updateProcessButton() {
      const btn = document.getElementById("processSplitsBtn");
      const statusText = document.getElementById("processSplitsStatus");
      const assignedCount = Object.keys(segmentSongMap).length;
      const undoBtn = document.getElementById('undoBtn');

      if (peaks && peaks.segments.getSegments().length > 0) {
        undoBtn.disabled = false;
      } else {
        undoBtn.disabled = true;
      }

      if (assignedCount > 0) {
        btn.disabled = false;
        if (statusText) {
          statusText.textContent = `${assignedCount} song(s) ready to process`;
        }
      } else {
        btn.disabled = true;
        if (statusText) {
          statusText.textContent =
            "Assign songs to segments to enable processing";
        }
      }
    }

    // Process splits button handler
    document
      .getElementById("processSplitsBtn")
      .addEventListener("click", async function () {
        if (Object.keys(segmentSongMap).length === 0) {
          alert("Please assign songs to segments first");
          return;
        }

        const splits = Object.values(segmentSongMap).map((assignment) => ({
          songId: assignment.songId,
          songTitle: assignment.songTitle,
          start: Math.floor(assignment.start),
          end: Math.floor(assignment.end),
          duration: Math.floor(assignment.end - assignment.start),
        }));

        // Show loading
        this.disabled = true;
        this.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';

        try {
          const response = await fetch(
            "/setlists/<%= setlist.id %>/recordings/<%= recording.id %>/process",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ splits }),
            }
          );

          if (response.ok) {
            const result = await response.json();
            alert(`Successfully split ${splits.length} songs!`);
            window.location.href =
              "/bands/<%= setlist.band.id %>/setlists/<%= setlist.id %>/recordings";
          } else {
            throw new Error("Failed to process splits");
          }
        } catch (error) {
          console.error("Processing error:", error);
          alert("Failed to process splits. Please try again.");
          this.disabled = false;
          this.innerHTML = '<i class="bi bi-scissors"></i> Process Splits';
        }
      });

    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) return "0:00";
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs.toString().padStart(2, "0")}`;
    }

    function showError(message) {
      const alertDiv = document.createElement("div");
      alertDiv.className = "alert alert-danger alert-dismissible fade show";
      alertDiv.innerHTML = `
              ${message}
              <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
          `;
      document.body.insertBefore(alertDiv, document.body.firstChild);
    }

    document.addEventListener('keydown', (e) => {
      // Ignore keyboard shortcuts if user is typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      if (e.key === 'Escape') {
        undoLastRegion();
      } else if (e.key === ' ') {
        e.preventDefault();
        document.getElementById('playPauseBtn').click();
      }
    });
  });
</script>
